<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Allotment Planner</title>
    <style>
        /* Base styles for entire page */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { overflow: hidden; font-family: sans-serif; background-color: #111; }
        #scene-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }

        /* General UI panel styling */
        .ui-panel {
            position: absolute;
            background-color: rgba(40, 40, 40, 0.9);
            color: #eee;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px); /* For Safari */
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px; /* Consistent padding for all ui-panels */
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Subtle shadow for depth */
            transition: opacity 0.3s ease, transform 0.3s ease; /* Smooth transitions for show/hide */
            z-index: 100; /* Ensure panels are above the 3D scene by default */
        }

        /* NEW: Unified .hidden class for all ui-panels */
        .ui-panel.hidden {
            opacity: 0;
            pointer-events: none; /* Allow clicks to pass through when hidden */
            transform: translateY(20px); /* A general transform for hiding */
            display: none; /* THIS IS THE CRITICAL ADDITION */
        }

        /* Ensure .ui-panel has a default display when NOT hidden */
        .ui-panel:not(.hidden) {
            display: block; /* Default display for most UI panels */
        }

        /* Tweakpane specific positioning for main controls */
        #main-controls-container {
            top: 15px;
            left: 15px;
            width: 280px;
            /* Max height to leave space for save/load panel below */
            max-height: calc(100vh - 30px - 250px); /* Adjusted for more buttons */
            overflow-y: auto; /* Enable scrolling if content exceeds height */
            z-index: 100; /* Explicit z-index */
        }
        /* Override Tweakpane's default absolute positioning for embedded panes */
        #main-controls-container .tp-dfwv {
            position: relative !important;
            top: auto;
            left: auto;
            width: auto !important; /* Allow it to fill parent */
            height: auto !important; /* Allow it to fit content */
        }

        /* Right Tool Panel (hosts Object Editor or Placement Settings dynamically) */
        #right-tool-panel-container {
            top: 15px; /* Aligned with sidebar and other top panels */
            right: 245px; /* Positioned to the left of the sidebar (220px width + 15px right margin) */
            width: 220px;
            max-height: calc(100vh - 30px); /* Allow scrolling for tall content */
            overflow-y: auto;
            z-index: 101; /* Explicit z-index: higher than main controls/sidebar */
        }
        #right-tool-panel-container .tp-dfwv { /* Override Tweakpane's defaults for embedded panes */
            position: relative !important;
            top: auto;
            left: auto;
            width: auto !important;
            height: auto !important;
        }
        /* Flexbox for labels and values in Tweakpane-generated embedded panels */
        #right-tool-panel-container .tp-lblv { display: flex; justify-content: space-between; align-items: center; }
        #right-tool-panel-container .tp-lblv_l { flex-grow: 1; }
        #right-tool-panel-container .tp-lblv_v { width: 110px; flex-shrink: 0; }

        /* Unified Sidebar Styling (Placeables list) */
        #sidebar-container {
            top: 15px;
            right: 15px;
            width: 220px;
            max-height: calc(100vh - 30px); /* Fill height, but leave space */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            z-index: 100; /* Explicit z-index */
        }
        /* NEW: Styling for the search input in the sidebar */
        #sidebar-search-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.3);
            color: #eee;
            font-size: 14px;
        }
        #sidebar-search-input:focus {
            outline: none;
            border-color: rgba(80, 150, 255, 0.5);
        }
        /* Container for the Tweakpane instance to allow scrolling */
        #sidebar-pane-container {
            flex-grow: 1; /* Allow this container to fill remaining space */
            overflow-y: auto; /* Enable scrolling for the Tweakpane content */
        }
        /* Specific Tweakpane styles for sidebar to ensure it looks right */
        #sidebar-pane-container .tp-dfwv {
            position: relative !important;
            top: auto;
            left: auto;
            width: 100% !important;
            background-color: transparent !important;
            border: none !important;
            padding: 0 !important;
            border-radius: 0 !important;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        /* General Tweakpane overrides: ensure they fit into ui-panel style */
        .tp-dfwv {
            background-color: transparent !important; /* Let ui-panel handle background */
            border: none !important; /* Let ui-panel handle border */
            box-shadow: none !important; /* Let ui-panel handle shadow */
        }

        /* Info Panel styles (for messages like "Saved", "Error", etc.) */
        #info-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 450px;
            text-align: center;
            z-index: 102; /* Highest z-index for alerts */
        }

        #info-panel #info-button {
            margin-top: 15px;
            padding: 8px 15px;
            border: none;
            background-color: #c84138; /* Red for action/dismiss */
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #info-panel #info-button:hover {
            background-color: #e06158;
        }
        #info-panel h3 { margin-bottom: 8px; font-size: 1.1em; }
        #info-panel p { font-size: 0.9em; }

        /* Save/Load Panel Styling */
        #saveLoadPanel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 280px; /* Match main controls width for symmetry */
            z-index: 99; /* Ensure it's above the summary panel */
            padding: 8px; /* Consistent with other panels */
        }
        #saveLoadPanel h3 {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgb(153, 153, 153);
            margin: 0 0 8px 0;
            padding: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 4px;
        }
        #saveLoadPanel button, #saveLoadPanel label.save-btn {
            width: 100%;
            margin-bottom: 6px;
            padding: 6px 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.1);
            color: rgb(242, 242, 242);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s, border-color 0.2s;
            text-align: center;
        }
        /* NEW: Styling for disabled buttons */
        #saveLoadPanel button:disabled {
            background-color: rgba(255, 255, 255, 0.05);
            color: rgba(242, 242, 242, 0.3);
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.05);
        }
        #saveLoadPanel button:not(:disabled):hover, #saveLoadPanel label.save-btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.2);
        }
        #saveLoadPanel button:not(:disabled):active, #saveLoadPanel label.save-btn:active {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        #saveLoadPanel button:last-of-type, #saveLoadPanel label.save-btn:last-of-type {
            margin-bottom: 0;
        }
        /* NEW: Button grid for undo/redo */
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        /* Specific styling for the import label/input to hide file input */
        #saveLoadPanel label.save-btn {
            display: block;
        }
        #saveLoadPanel #importFile {
            display: none;
        }

        /* Plant Summary Panel Styling */
        #plant-summary-panel {
            left: 50%;
            transform: translateX(-50%);
            width: 1500px;
            max-width: calc(100vw - 30px);
            top: 15px;
            max-height: calc(100vh - 30px - 150px);
            overflow-y: auto;
            overflow-x: auto;
            z-index: 100;
        }
        #plant-summary-panel table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
            table-layout: fixed;
        }
        #plant-summary-panel th, #plant-summary-panel td {
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: top;
        }
        #plant-summary-panel thead tr {
            background-color: rgba(255,255,255,0.05);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        #plant-summary-panel th:nth-child(1) { width: 220px; }
        #plant-summary-panel th:nth-child(2) { width: 120px; }
        #plant-summary-panel th:nth-child(3) { width: 160px; }
        #plant-summary-panel th:nth-child(4) { width: 160px; }
        #plant-summary-panel th:nth-child(5) { width: 120px; }
        #plant-summary-panel th:nth-child(6) { width: 220px; }
        #plant-summary-panel th:nth-child(7) { width: 170px; }
        #plant-summary-panel th:nth-child(8) { width: 200px; }
        #plant-summary-panel th:nth-child(9) { width: 130px; }


        #plant-summary-panel h3, #plant-summary-panel p {
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: rgb(153, 153, 153);
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Responsive adjustments for smaller screens (e.g., mobile) */
        @media (max-width: 768px) {
            #main-controls-container,
            #sidebar-container,
            #right-tool-panel-container {
                width: calc(100% - 30px);
                left: 15px;
                right: 15px;
                top: 15px;
                max-height: 45vh;
            }
         
            #sidebar-container { top: calc(15px + 45vh + 15px); max-height: 45vh; }
            #right-tool-panel-container { top: calc(15px + 45vh + 15px); z-index: 101; }
            #saveLoadPanel { width: calc(100% - 30px); left: 15px; bottom: 15px; }
            #info-panel { width: calc(100% - 30px); }
            #plant-summary-panel {
                top: calc(15px + 45vh + 15px + 45vh + 15px);
                bottom: calc(15px + 120px);
                left: 15px;
                width: calc(100% - 30px);
                right: 15px;
                max-width: unset;
                max-height: unset;
                overflow-y: auto;
                overflow-x: auto;
                transform: none;
            }
            #plant-summary-panel th, #plant-summary-panel td {
                width: auto;
                white-space: normal;
            }
        }
        
        /* 3D Axis Indicator Container (FIXED) */
        #axis-indicator-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            z-index: 250; /* Raised above info button */
            pointer-events: none; /* Allows clicks to pass through */
        }
    </style>
</head>
<body>
    <!-- Info Button and Modal -->
    <button id="info-btn" style="position:fixed;bottom:20px;right:20px;z-index:200;width:40px;height:40px;border-radius:50%;background:#222;color:#fff;font-size:1.5em;border:none;box-shadow:0 2px 8px #0006;cursor:pointer;">i</button>
    <div id="info-modal" style="display:none;position:fixed;bottom:70px;right:20px;z-index:201;background:rgba(30,30,30,0.98);color:#fff;padding:24px 32px 18px 32px;border-radius:12px;box-shadow:0 4px 24px #000a;min-width:260px;max-width:90vw;">
      <div style="font-size:1.2em;font-weight:bold;margin-bottom:8px;">About This Build</div>
      <div><b>Version:</b> <span id="build-version">1.0.0</span></div>
      <div><b>Builder:</b> Four20 (with AI help)</div>
      <div><b>Build Date:</b> <span id="build-date">2024-06-09</span></div>
      <button id="close-info-modal" style="margin-top:16px;padding:6px 18px;border:none;background:#444;color:#fff;border-radius:6px;cursor:pointer;">Close</button>
    </div>

    <!-- HTML STRUCTURE -->
    <div id="scene-container"></div>

    <!-- Main Allotment Controls Panel (always visible) -->
    <div id="main-controls-container" class="ui-panel"></div>

    <!-- Dynamic Right Tool Panel (Object Editor or Placement Settings dynamically) -->
    <div id="right-tool-panel-container" class="ui-panel hidden"></div>

    <!-- Placeables Sidebar (always visible) -->
    <div id="sidebar-container" class="ui-panel">
        <!-- Search input will be prepended here by JS -->
        <div id="sidebar-pane-container"></div>
    </div>

    <!-- Plant Summary Panel -->
    <div id="plant-summary-panel" class="ui-panel hidden">
        <!-- Content will be generated by JavaScript -->
    </div>

    <!-- Info Panel (for messages/alerts) -->
    <div id="info-panel" class="ui-panel hidden">
        <h3 id="info-title"></h3>
        <p id="info-details"></p>
        <button id="info-button">Action</button>
    </div>

    <!-- Save/Load Panel (always visible) -->
    <div id="saveLoadPanel" class="ui-panel">
        <h3>Layout Tools</h3>
        <!-- NEW: Undo/Redo buttons in a grid -->
        <div class="button-grid">
            <button id="undoBtn">↩️ Undo</button>
            <button id="redoBtn">↪️ Redo</button>
        </div>
        <hr style="border-color: rgba(255, 255, 255, 0.1); margin: 6px 0;">
        <button id="saveLayoutBtn">💾 Save Layout</button>
        <button id="loadLayoutBtn">📂 Load Layout</button>
        <button id="exportLayoutBtn">⬇ Export JSON</button>
        <label class="save-btn">
            📁 Import JSON
            <input type="file" id="importFile" accept=".json" />
        </label>
        <button id="randomizeLayoutBtn" style="background-color: rgba(60, 120, 220, 0.2);">🎲 Randomize</button>
                <button id="clearAllBtn" style="background-color: rgba(220, 60, 60, 0.2);">⚠️ Clear All</button>
        <hr style="border-color: rgba(255, 255, 255, 0.1); margin: 6px 0;">
        <button id="perimeterFenceBtn" style="background-color: rgba(120, 200, 200, 0.2);">🏗️ Perimeter Fence</button>
        <hr style="border-color: rgba(255, 255, 255, 0.1); margin: 6px 0;">
        <h3>Reports</h3>
        <button id="exportPlantSummaryBtn">🖨️ Export Plant Summary</button>
    </div>

    <!-- 3D Axis Indicator -->
    <div id="axis-indicator-container"></div>

    <!-- Axis Indicator Toggle Button -->
    <button id="axis-indicator-toggle-btn" title="Show/Hide Axis Widget" style="position:fixed;bottom:130px;right:20px;z-index:251;width:44px;height:44px;border-radius:50%;background:#222;color:#fff;font-size:1.6em;border:none;box-shadow:0 2px 8px #0006;cursor:pointer;display:flex;align-items:center;justify-content:center;">👁️</button>


    <!-- JAVASCRIPT LIBRARIES -->
    <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.8/dist/tweakpane.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>

    <!-- APPLICATION JAVASCRIPT -->
    <script>
        // --- 1. DEFINE ALL CONSTANTS, CLASSES, AND FUNCTIONS ---

        const UNITS = {
            m:  { factor: 1,       symbol: 'm',  system: 'metric', label: 'Meters' },
            cm: { factor: 100,     symbol: 'cm', system: 'metric', label: 'Centimeters' },
            ft: { factor: 3.28084, symbol: 'ft', system: 'imperial', label: 'Feet' },
            in: { factor: 39.3701, symbol: 'in', system: 'imperial', label: 'Inches' }
        };
        const METRIC_SUBDIVISIONS = { '1m': 1.0, '50cm': 0.5, '25cm': 0.25, '10cm': 0.1 };
        const IMPERIAL_SUBDIVISIONS = { '1yd': 0.9144, '1ft': 0.3048, '6in': 0.1524, '1in': 0.0254 };

        const STRUCTURES = [
            { name: 'Shed', width: 2, depth: 3, height: 2.2, snappable: false, resizable: true, materialProps: { color: 0xA0522D, roughness: 0.9 } },
            { name: 'Greenhouse', width: 2, depth: 4, height: 2.5, snappable: false, resizable: true, materialProps: { color: 0x9ACD32, roughness: 0.1, transparent: true, opacity: 0.5 } },
            { name: 'Planter', width: 1, depth: 2, height: 0.5, snappable: false, resizable: true,
              materialProps: { color: 0xCD853F, roughness: 0.8, transparent: true, opacity: 0.8 },
              isHollow: true, defaultWallThickness: 0.05, defaultSoilHeight: 0.3,
              soilRows: 2, soilCols: 2
            },
            { name: 'Water Butt', width: 0.8, depth: 0.8, height: 1.2, snappable: false, resizable: false, materialProps: { color: 0x2E4034, roughness: 0.2, metalness: 0.1 } }, // Not resizable
            { name: 'Fence Section', width: 2, depth: 0.1, height: 1.0, snappable: true, resizable: true, materialProps: { color: 0x8B4513, roughness: 0.9 } },
            { name: 'Gate', width: 1.2, depth: 0.1, height: 1.2, snappable: true, resizable: true, materialProps: { color: 0x8B4513, roughness: 0.9 } },
            { name: 'Chicken Coop', width: 2.5, depth: 1.5, height: 1.8, snappable: false, resizable: true, materialProps: { color: 0xB5651D, roughness: 0.9 } },
            { name: 'Polytunnel', width: 3, depth: 6, height: 2.2, snappable: false, resizable: true, materialProps: { color: 0xF5F5F5, roughness: 0.2, transparent: true, opacity: 0.6 } },
            { name: 'Composter', width: 1, depth: 1, height: 1, snappable: false, resizable: true, materialProps: { color: 0x654321, roughness: 0.95 } },
            { name: 'EU Pallet', width: 1.2, depth: 0.8, height: 0.144, snappable: false, resizable: false, materialProps: { color: 0xDEB887, roughness: 1.0 } }, // Not resizable
        ];

        // UPDATED PLANTS DATA
        const PLANTS = {
            vegetables: [
                { name: 'Potatoes', width: 0.4, height: 0.3, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'High (Many tubers)', avgGrowthTime: '90-120 days', sowTime: 'Early Spring', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.4x0.4x0.3m', avgWaterLitersPerWeek: 5 },
                { name: 'Carrots', width: 0.25, height: 0.2, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (Root crop)', avgGrowthTime: '70-90 days', sowTime: 'Early Spring-Late Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.25x0.25x0.2m', avgWaterLitersPerWeek: 3 },
                { name: 'Onions', width: 0.2, height: 0.15, depth: 0.2, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low', yield: 'Medium (Bulb crop)', avgGrowthTime: '100-175 days', sowTime: 'Early Spring', harvestTime: 'Late Summer', typicalSizeStr: '0.2x0.2x0.15m', avgWaterLitersPerWeek: 2 },
                { name: 'Garlic', width: 0.2, height: 0.15, depth: 0.2, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low', yield: 'Medium (Bulb crop)', avgGrowthTime: '240-270 days', sowTime: 'Autumn', harvestTime: 'Summer', typicalSizeStr: '0.2x0.2x0.15m', avgWaterLitersPerWeek: 2 },
                { name: 'Leeks', width: 0.25, height: 0.4, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Medium', avgGrowthTime: '120-180 days', sowTime: 'Early Spring', harvestTime: 'Autumn-Winter', typicalSizeStr: '0.25x0.25x0.4m', avgWaterLitersPerWeek: 4 },
                { name: 'Beetroot', width: 0.3, height: 0.25, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Good (Root crop)', avgGrowthTime: '50-60 days', sowTime: 'Spring-Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.3x0.3x0.25m', avgWaterLitersPerWeek: 3 },
                { name: 'Turnips', width: 0.3, height: 0.2, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Good (Root crop)', avgGrowthTime: '40-60 days', sowTime: 'Spring-Late Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.3x0.3x0.2m', avgWaterLitersPerWeek: 3 },
                { name: 'Parsnips', width: 0.3, height: 0.3, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Medium (Root crop)', avgGrowthTime: '120-180 days', sowTime: 'Early Spring', harvestTime: 'Autumn-Winter', typicalSizeStr: '0.3x0.3x0.3m', avgWaterLitersPerWeek: 4 },
                { name: 'Radishes', width: 0.2, height: 0.1, depth: 0.2, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'High', yield: 'Fast & Frequent', avgGrowthTime: '20-30 days', sowTime: 'Spring-Autumn', harvestTime: 'Spring-Autumn', typicalSizeStr: '0.2x0.2x0.1m', avgWaterLitersPerWeek: 3 },
                { name: 'Cabbages', width: 0.5, height: 0.4, depth: 0.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Medium', avgGrowthTime: '60-100 days', sowTime: 'Early Spring-Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.5x0.5x0.4m', avgWaterLitersPerWeek: 5 },
                { name: 'Cauliflower', width: 0.5, height: 0.4, depth: 0.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Medium', avgGrowthTime: '80-120 days', sowTime: 'Spring-Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.5x0.5x0.4m', avgWaterLitersPerWeek: 6 },
                { name: 'Broccoli', width: 0.45, height: 0.5, depth: 0.45, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Good', avgGrowthTime: '60-100 days', sowTime: 'Spring-Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.45x0.45x0.5m', avgWaterLitersPerWeek: 5 },
                { name: 'Kale', width: 0.5, height: 0.7, depth: 0.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Consistent', avgGrowthTime: '55-75 days', sowTime: 'Spring-Summer', harvestTime: 'Summer-Winter', typicalSizeStr: '0.5x0.5x0.7m', avgWaterLitersPerWeek: 4 },
                { name: 'Brussels sprouts', width: 0.4, height: 0.8, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good', avgGrowthTime: '90-110 days', sowTime: 'Spring', harvestTime: 'Autumn-Winter', typicalSizeStr: '0.4x0.4x0.8m', avgWaterLitersPerWeek: 5 },
                { name: 'Spinach', width: 0.35, height: 0.2, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Partial Shade', water: 'Medium', yield: 'Frequent (Cut & Come Again)', avgGrowthTime: '30-45 days', sowTime: 'Early Spring-Autumn', harvestTime: 'Spring-Autumn', typicalSizeStr: '0.35x0.35x0.2m', avgWaterLitersPerWeek: 3 },
                { name: 'Swiss chard', width: 0.35, height: 0.3, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Consistent', avgGrowthTime: '50-60 days', sowTime: 'Spring-Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.35x0.35x0.3m', avgWaterLitersPerWeek: 4 },
                { name: 'Lettuce', width: 0.25, height: 0.2, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Partial Shade', water: 'Medium-High', yield: 'Frequent', avgGrowthTime: '40-80 days', sowTime: 'Early Spring-Autumn', harvestTime: 'Spring-Autumn', typicalSizeStr: '0.25x0.25x0.2m', avgWaterLitersPerWeek: 3 },
                { name: 'Rocket', width: 0.25, height: 0.15, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Fast & Frequent', avgGrowthTime: '20-40 days', sowTime: 'Spring-Autumn', harvestTime: 'Spring-Autumn', typicalSizeStr: '0.25x0.25x0.15m', avgWaterLitersPerWeek: 3 },
                { name: 'Mustard greens', width: 0.25, height: 0.2, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Frequent', avgGrowthTime: '30-50 days', sowTime: 'Spring-Late Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.25x0.25x0.2m', avgWaterLitersPerWeek: 3 },
                { name: 'Peas', width: 0.3, height: 1.0, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (Pod crop)', avgGrowthTime: '60-80 days', sowTime: 'Early Spring', harvestTime: 'Summer', typicalSizeStr: '0.3x0.3x1.0m', avgWaterLitersPerWeek: 5 },
                { name: 'Broad beans', width: 0.35, height: 1.2, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (Pod crop)', avgGrowthTime: '90-120 days', sowTime: 'Autumn-Early Spring', harvestTime: 'Late Spring-Early Summer', typicalSizeStr: '0.35x0.35x1.2m', avgWaterLitersPerWeek: 6 },
                { name: 'Runner beans', width: 0.4, height: 2.0, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Very High (Climbing)', avgGrowthTime: '60-80 days', sowTime: 'Late Spring', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.4x0.4x2.0m', avgWaterLitersPerWeek: 8 },
                { name: 'French beans', width: 0.3, height: 0.8, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Good', avgGrowthTime: '50-60 days', sowTime: 'Late Spring', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.3x0.3x0.8m', avgWaterLitersPerWeek: 5 },
                { name: 'Courgettes', width: 0.8, height: 0.5, depth: 0.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Prolific', avgGrowthTime: '50-60 days', sowTime: 'Late Spring', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.8x0.8x0.5m', avgWaterLitersPerWeek: 10 },
                { name: 'Marrows', width: 1.0, height: 0.6, depth: 1.0, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'High', avgGrowthTime: '90-120 days', sowTime: 'Late Spring', harvestTime: 'Autumn', typicalSizeStr: '1.0x1.0x0.6m', avgWaterLitersPerWeek: 12 },
                { name: 'Pumpkins', width: 1.5, height: 0.5, depth: 1.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Medium', avgGrowthTime: '90-120 days', sowTime: 'Late Spring', harvestTime: 'Autumn', typicalSizeStr: '1.5x1.5x0.5m', avgWaterLitersPerWeek: 15 },
                { name: 'Squash', width: 1.2, height: 0.5, depth: 1.2, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Good', avgGrowthTime: '90-120 days', sowTime: 'Late Spring', harvestTime: 'Autumn', typicalSizeStr: '1.2x1.2x0.5m', avgWaterLitersPerWeek: 12 },
                { name: 'Cucumbers', width: 0.8, height: 1.5, depth: 0.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Consistent', avgGrowthTime: '50-70 days', sowTime: 'Late Spring', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.8x0.8x1.5m', avgWaterLitersPerWeek: 7 },
                { name: 'Sweetcorn', width: 0.3, height: 1.8, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Good', avgGrowthTime: '60-100 days', sowTime: 'Late Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr: '0.3x0.3x1.8m', avgWaterLitersPerWeek: 6 },
                { name: 'Tomatoes', width: 0.6, height: 1.5, depth: 0.6, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'High', avgGrowthTime: '60-90 days', sowTime: 'Early Spring (indoors), Late Spring (outdoors)', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.6x0.6x1.5m', avgWaterLitersPerWeek: 7 },
                { name: 'Peppers', width: 0.4, height: 0.8, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Medium', avgGrowthTime: '60-90 days', sowTime: 'Early Spring (indoors)', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.4x0.4x0.8m', avgWaterLitersPerWeek: 5 },
                { name: 'Aubergines', width: 0.4, height: 0.8, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Medium', avgGrowthTime: '70-90 days', sowTime: 'Early Spring (indoors)', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.4x0.4x0.8m', avgWaterLitersPerWeek: 6 },
                { name: 'Celery', width: 0.25, height: 0.4, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'High', yield: 'Medium', avgGrowthTime: '85-100 days', sowTime: 'Early Spring-Summer', harvestTime: 'Autumn-Winter', typicalSizeStr: '0.25x0.25x0.4m', avgWaterLitersPerWeek: 4 },
                { name: 'Fennel', width: 0.25, height: 0.4, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (Bulb)', avgGrowthTime: '60-90 days', sowTime: 'Spring-Late Summer', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.25x0.25x0.4m', avgWaterLitersPerWeek: 4 },
                { name: 'Spring onions', width: 0.1, height: 0.15, depth: 0.1, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x5a8e3b, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Fast & Frequent', avgGrowthTime: '30-60 days', sowTime: 'All Year (succession)', harvestTime: 'All Year (succession)', typicalSizeStr: '0.1x0.1x0.15m', avgWaterLitersPerWeek: 1 },
            ],
            fruits: [
                { name: 'Strawberries', width: 0.25, height: 0.15, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xDC143C, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Good (1-2 lbs/plant)', avgGrowthTime: '1-2 years (establish)', sowTime: 'Spring-Autumn', harvestTime: 'Late Spring-Summer', typicalSizeStr: '0.25x0.25x0.15m', avgWaterLitersPerWeek: 4 },
                { name: 'Raspberries', width: 0.4, height: 1.5, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xDC143C, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Consistent (2-4 lbs/cane)', avgGrowthTime: '1-2 years (establish)', sowTime: 'Autumn-Spring', harvestTime: 'Summer-Autumn', typicalSizeStr: '0.4x0.4x1.5m', avgWaterLitersPerWeek: 5 },
                { name: 'Blackberries', width: 0.4, height: 1.8, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x000000, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'High (5-10 lbs/cane)', avgGrowthTime: '1-2 years (establish)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr: '0.4x0.4x1.8m', avgWaterLitersPerWeek: 6 },
                { name: 'Blueberries', width: 0.5, height: 1.0, depth: 0.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x4682B4, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Good (3-5 lbs/bush)', avgGrowthTime: '2-3 years (establish)', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr: '0.5x0.5x1.0m', avgWaterLitersPerWeek: 5 },
                { name: 'Gooseberries', width: 0.6, height: 1.2, depth: 0.6, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xADFF2F, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Good (4-8 lbs/bush)', avgGrowthTime: '1-2 years (establish)', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr: '0.6x0.6x1.2m', avgWaterLitersPerWeek: 5 },
                { name: 'Currants', width: 0.5, height: 1.2, depth: 0.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFF0000, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Good (3-6 lbs/bush)', avgGrowthTime: '1-2 years (establish)', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr: '0.5x0.5x1.2m', avgWaterLitersPerWeek: 4 },
                { name: 'Rhubarb', width: 0.7, height: 0.6, depth: 0.7, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x8B0000, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium-High', yield: 'Consistent (10-20 lbs/plant)', avgGrowthTime: '1 year (establish)', sowTime: 'Spring-Autumn', harvestTime: 'Spring-Summer', typicalSizeStr: '0.7x0.7x0.6m', avgWaterLitersPerWeek: 7 },
                { name: 'Dwarf Apple', width: 2.0, height: 2.5, depth: 2.0, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (20-40 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '2.0x2.0x2.5m', avgWaterLitersPerWeek: 15 },
                { name: 'Pears', width: 2.0, height: 2.5, depth: 2.0, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (20-50 lbs/tree)', avgGrowthTime: '4-6 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '2.0x2.0x2.5m', avgWaterLitersPerWeek: 15 },
                { name: 'Plums', width: 1.8, height: 2.8, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (30-60 lbs/tree)', avgGrowthTime: '3-6 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '1.8x1.8x2.8m', avgWaterLitersPerWeek: 12 },
                { name: 'Cherries', width: 1.8, height: 2.8, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (20-50 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr  : '1.8x1.8x2.8m', avgWaterLitersPerWeek: 12 },
                { name: 'Figs', width: 1.8, height: 2.0, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (10-20 lbs/tree)', avgGrowthTime: '2-3 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '1.8x1.8x2.0m', avgWaterLitersPerWeek: 10 },
                { name: 'Grapes', width: 0.8, height: 2.5, depth: 0.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x6A5ACD, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (5-10 lbs/vine)', avgGrowthTime: '2-3 years (first fruit)', sowTime: 'Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '0.8x0.8x2.5m', avgWaterLitersPerWeek: 8 },
                { name: 'Melons', width: 1.0, height: 0.4, depth: 1.0, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x9ACD32, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'High', yield: 'Medium (2-4 melons/plant)', avgGrowthTime: '80-100 days', sowTime: 'Late Spring', harvestTime: 'Late Summer', typicalSizeStr  : '1.0x1.0x0.4m', avgWaterLitersPerWeek: 10 },
            ],
            flowers: [
                { name: 'Marigolds', width: 0.25, height: 0.3, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFFA500, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low-Medium', yield: 'Consistent blooms', avgGrowthTime: '45-60 days', sowTime: 'Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.25x0.25x0.3m', avgWaterLitersPerWeek: 3 },
                { name: 'Nasturtiums', width: 0.35, height: 0.2, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFFD700, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Low', yield: 'Good (Edible flowers)', avgGrowthTime: '35-50 days', sowTime: 'Spring-Summer', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.35x0.35x0.2m', avgWaterLitersPerWeek: 3 },
                { name: 'Calendula', width: 0.25, height: 0.4, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFF8C00, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low-Medium', yield: 'Good (Edible/Medicinal)', avgGrowthTime: '60-80 days', sowTime: 'Spring-Late Summer', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.25x0.25x0.4m', avgWaterLitersPerWeek: 3 },
                { name: 'Borage', width: 0.5, height: 0.6, depth: 0.5, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x6A5ACD, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (Pollinator/Edible)', avgGrowthTime: '50-60 days', sowTime: 'Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.5x0.5x0.6m', avgWaterLitersPerWeek: 4 },
                { name: 'Sunflowers', width: 0.4, height: 2.0, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFFD700, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium-High', yield: 'Seeds (1 head/plant)', avgGrowthTime: '70-100 days', sowTime: 'Late Spring', harvestTime: 'Autumn', typicalSizeStr  : '0.4x0.4x2.0m', avgWaterLitersPerWeek: 7 },
                { name: 'Sweet peas', width: 0.3, height: 1.5, depth: 0.3, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xDA70D6, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Many blooms', avgGrowthTime: '70-90 days', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr  : '0.3x0.3x1.5m', avgWaterLitersPerWeek: 5 },
                { name: 'Dahlias', width: 0.4, height: 1.0, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFF69B4, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Showy blooms', avgGrowthTime: '90-120 days', sowTime: 'Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.4x0.4x1.0m', avgWaterLitersPerWeek: 5 },
                { name: 'Zinnias', width: 0.35, height: 0.7, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFF4500, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low-Medium', yield: 'Many blooms', avgGrowthTime: '60-70 days', sowTime: 'Late Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.35x0.35x0.7m', avgWaterLitersPerWeek: 4 },
                { name: 'Cosmos', width: 0.35, height: 0.8, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xADD8E6, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low-Medium', yield: 'Consistent blooms', avgGrowthTime: '60-90 days', sowTime: 'Late Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.35x0.35x0.8m', avgWaterLitersPerWeek: 4 },
                { name: 'Lavender', width: 0.4, height: 0.6, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xBA55D3, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low', yield: 'Fragrant blooms', avgGrowthTime: '1-2 years (establish)', sowTime: 'Spring-Autumn', harvestTime: 'Summer', typicalSizeStr  : '0.4x0.4x0.6m', avgWaterLitersPerWeek: 3 },
                { name: 'Echinacea', width: 0.35, height: 0.7, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xDAA520, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Low-Medium', yield: 'Medicinal/Pollinator', avgGrowthTime: '1-2 years (establish)', sowTime: 'Spring-Autumn', harvestTime: 'Summer-Autumn', typicalSizeStr  : '0.35x0.35x0.7m', avgWaterLitersPerWeek: 4 },
                { name: 'Cornflowers', width: 0.25, height: 0.5, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x6495ED, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low-Medium', yield: 'Many blooms', avgGrowthTime: '60-80 days', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr  : '0.25x0.25x0.5m', avgWaterLitersPerWeek: 3 },
                { name: 'Poppies', width: 0.25, height: 0.6, depth: 0.25, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0xFF0000, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Low', yield: 'Many blooms', avgGrowthTime: '60-80 days', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr  : '0.25x0.25x0.6m', avgWaterLitersPerWeek: 2 },
                { name: 'Foxgloves', width: 0.35, height: 1.5, depth: 0.35, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x800080, transparent: true, opacity: 0.8 }, light: 'Partial Shade', water: 'Medium', yield: 'Tall blooms', avgGrowthTime: '1 year (biennial)', sowTime: 'Summer', harvestTime: 'Next Summer', typicalSizeStr  : '0.35x0.35x1.5m', avgWaterLitersPerWeek: 5 },
                { name: 'Lupins', width: 0.4, height: 1.0, depth: 0.4, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x4682B4, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Showy blooms', avgGrowthTime: '1 year (establish)', sowTime: 'Autumn-Spring', harvestTime: 'Early Summer', typicalSizeStr  : '0.4x0.4x1.0m', avgWaterLitersPerWeek: 5 },
            ],
            trees: [
                { name: 'Apple Tree', width: 2.0, height: 3.0, depth: 2.0, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Seasonal fruit (50-100 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '2.0x2.0x3.0m', avgWaterLitersPerWeek: 15 },
                { name: 'Pear Tree', width: 2.0, height: 3.0, depth: 2.0, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Seasonal fruit (50-100 lbs/tree)', avgGrowthTime: '4-6 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '2.0x2.0x3.0m', avgWaterLitersPerWeek: 15 },
                { name: 'Plum Tree', width: 1.8, height: 2.8, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (30-60 lbs/tree)', avgGrowthTime: '3-6 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Summer-Autumn', typicalSizeStr  : '1.8x1.8x2.8m', avgWaterLitersPerWeek: 12 },
                { name: 'Cherry Tree', width: 1.8, height: 2.8, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (20-50 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr  : '1.8x1.8x2.8m', avgWaterLitersPerWeek: 12 },
                { name: 'Damson Tree', width: 1.8, height: 2.8, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Seasonal fruit (30-60 lbs/tree)', avgGrowthTime: '3-6 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '1.8x1.8x2.8m', avgWaterLitersPerWeek: 12 },
                { name: 'Quince Tree', width: 1.8, height: 2.5, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Seasonal fruit (20-40 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Autumn', typicalSizeStr  : '1.8x1.8x2.5m', avgWaterLitersPerWeek: 10 },
                { name: 'Fig Tree', width: 1.8, height: 2.5, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Good (10-20 lbs/tree)', avgGrowthTime: '2-3 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Summer-Autumn', typicalSizeStr  : '1.8x1.8x2.5m', avgWaterLitersPerWeek: 10 },
                { name: 'Hazel (cobnut)', width: 1.8, height: 2.5, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun-Partial Shade', water: 'Medium', yield: 'Nuts (5-10 lbs/tree)', avgGrowthTime: '3-5 years (first crop)', sowTime: 'Autumn-Spring', harvestTime: 'Autumn', typicalSizeStr  : '1.8x1.8x2.5m', avgWaterLitersPerWeek: 8 },
                { name: 'Medlar Tree', width: 1.8, height: 2.5, depth: 1.8, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Seasonal fruit (10-20 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Late Autumn', typicalSizeStr  : '1.8x1.8x2.5m', avgWaterLitersPerWeek: 10 },
                { name: 'Mulberry Tree', width: 2.2, height: 3.5, depth: 2.2, isScalable: true, defaultGrowth: 0.5, snappable: false, materialProps: { color: 0x228B22, transparent: true, opacity: 0.8 }, light: 'Full Sun', water: 'Medium', yield: 'Seasonal fruit (30-70 lbs/tree)', avgGrowthTime: '3-5 years (first fruit)', sowTime: 'Autumn-Spring', harvestTime: 'Summer', typicalSizeStr  : '2.2x2.2x3.5m', avgWaterLitersPerWeek: 18 },
            ]
        };

        const clock = new THREE.Clock();
        const THEMES = {
            light: { sky: '#87CEEB', ground: '#6B8E23', text: '#222222', grid: '#444444', gradientTop: '#87CEEB', gradientBottom: '#6e9ac2' },
            dark: { sky: '#111827', ground: '#556B2F', text: '#EEEEEE', grid: '#FFFFFF', gradientTop: '#0d1a2f', gradientBottom: '#111827' }
        };

        function convertFromMeters(value, toUnit) { return value * UNITS[toUnit].factor; }
        function convertToMeters(value, fromUnit) { return value / UNITS[fromUnit].factor; }

        function createCamera() { const c = new THREE.PerspectiveCamera(35, 1, 0.1, 1000); c.position.set(-20, 25, 20); c.lookAt(0, 0, 0); return c; }
        
        function createLights() {
            const hemiLight = new THREE.HemisphereLight(0xadd8e6, 0x6B8E23, 0.6);
            const sunLight = new THREE.DirectionalLight(0xffefd5, 1.2);
            sunLight.position.set(-25, 30, 15);
            sunLight.target.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            return { hemiLight: hemiLight, sunLight: sunLight };
        }

        function createScene() { const s = new THREE.Scene(); return s; }

        function createRenderer() {
            const r = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:true for indicator
            r.physicallyCorrectLights = true;
            r.shadowMap.enabled = true;
            r.shadowMap.type = THREE.PCFSoftShadowMap;
            return r;
        }
        
        function createPlot() {
            const plotThickness = 0.2;
            const geometry = new THREE.BoxGeometry(1, plotThickness, 1);
            const material = new THREE.MeshStandardMaterial({ color: '#556B2F' });
            const plotMesh = new THREE.Mesh(geometry, material);
            plotMesh.position.y = -plotThickness / 2;
            plotMesh.name = 'ground';
            plotMesh.receiveShadow = true;
            const grid = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 }));
            return { ground: plotMesh, grid: grid, thickness: plotThickness };
        }

        // --- NEW: UNDO MANAGER ---
        class UndoManager {
            constructor(world) {
                this.world = world;
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistory = 50;
                this.isUndoingOrRedoing = false; // Flag to prevent cycles

                this.undoBtn = document.getElementById('undoBtn');
                this.redoBtn = document.getElementById('redoBtn');

                this.undoBtn.addEventListener('click', () => this.undo());
                this.redoBtn.addEventListener('click', () => this.redo());

                this.updateButtons();
            }

            saveState() {
                if (this.isUndoingOrRedoing) return;

                const currentState = this.world.getCurrentLayoutData();
                this.undoStack.push(JSON.stringify(currentState));
                
                if (this.undoStack.length > this.maxHistory) {
                    this.undoStack.shift(); // Remove the oldest state
                }

                // Clear the redo stack whenever a new action is taken
                this.redoStack = [];
                this.updateButtons();
            }

            undo() {
                if (this.undoStack.length <= 1) return; // Can't undo the initial state
                
                this.isUndoingOrRedoing = true;
                
                const currentState = this.undoStack.pop();
                this.redoStack.push(currentState);
                
                const previousState = this.undoStack[this.undoStack.length - 1];
                this.world.rebuildSceneFromData(JSON.parse(previousState), "Undo");

                this.isUndoingOrRedoing = false;
                this.updateButtons();
            }

            redo() {
                if (this.redoStack.length === 0) return;
                
                this.isUndoingOrRedoing = true;

                const nextState = this.redoStack.pop();
                this.undoStack.push(nextState);

                this.world.rebuildSceneFromData(JSON.parse(nextState), "Redo");

                this.isUndoingOrRedoing = false;
                this.updateButtons();
            }

            clear() {
                this.undoStack = [];
                this.redoStack = [];
                this.saveState(); // Save the initial empty state
                this.updateButtons();
            }

            updateButtons() {
                this.undoBtn.disabled = this.undoStack.length <= 1;
                this.redoBtn.disabled = this.redoStack.length === 0;
            }
        }
        
        // --- START: FIXED/ADDED AxisIndicator Class ---
        class AxisIndicator {
            constructor(container) {
                this.container = container;
                // --- OPTIMIZATION: Fix canvas size and pixel ratio ---
                this.width = 100;
                this.height = 100;
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(50, this.width / this.height, 0.1, 10);
                this.camera.up.set(0, 1, 0); // Explicitly set up vector

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(1); // OPTIMIZATION: Lower pixel ratio
                this.container.style.width = this.width + 'px';
                this.container.style.height = this.height + 'px';
                this.container.appendChild(this.renderer.domElement);

                const length = 1;
                const headLength = 0.2;
                const headWidth = 0.1;

                // Axes
                this.scene.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), length, 0xff0000, headLength, headWidth)); // X - Red
                this.scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), length, 0x00ff00, headLength, headWidth)); // Y - Green
                this.scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 0), length, 0x0000ff, headLength, headWidth)); // Z - Blue (flipped)
            }

            update(mainCamera) {
                // Place indicator camera at a fixed distance, rotated by main camera's orientation
                const camDistance = 3;
                const basePosition = new THREE.Vector3(0, 0, camDistance);
                basePosition.applyQuaternion(mainCamera.quaternion);
                this.camera.position.copy(basePosition);
                this.camera.lookAt(0, 0, 0);
                this.renderer.render(this.scene, this.camera);
            }

            onResize() {
                // Keep fixed size for performance
                this.camera.aspect = this.width / this.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.width, this.height);
            }
        }
        // --- END: FIXED/ADDED AxisIndicator Class ---

        class Loop {
            constructor(camera, scene, renderer) { this.camera = camera; this.scene = scene; this.renderer = renderer; this.updatables = []; }
            start(world) { 
                this.renderer.setAnimationLoop(() => { 
                    this.tick(); 
                    
                    // Main render
                    this.renderer.render(this.scene, this.camera); 
                    
                    // Axis indicator render (if it exists and is visible)
                    if (world && world.axisIndicator && world.axisIndicatorVisible) {
                        world.axisIndicator.update(world.camera);
                    }
                }); 
            }
            tick() { const delta = clock.getDelta(); for (const object of this.updatables) { if (object.update) object.update(delta); } }
        }

        class Rulers {
            constructor() { this.container = new THREE.Group(); this.container.position.y = 0.01; }
            _createTextSprite(text, position, color = 'white', fontSize = 48) {
                const canvas = document.createElement('canvas'); const context = canvas.getContext('2d');
                context.font = `${fontSize}px Arial`; const textWidth = context.measureText(text).width;
                canvas.width = textWidth + 16; canvas.height = fontSize + 16;
                context.font = `${fontSize}px Arial`; context.fillStyle = color; context.textAlign = 'center'; context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: true, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(canvas.width * 0.005, canvas.height * 0.005, 1.0);
                sprite.position.copy(position); return sprite;
            }
            update(width, length, unitsKey, theme, subdivisions = 1) {
                while (this.container.children.length > 0) { this.container.remove(this.container.children[0]); }
                const cF = UNITS[unitsKey].factor; const unitSymbol = UNITS[unitsKey].symbol;
                const majorTickLength = 0.4; const minorTickLength = 0.2;
                const textOffsetFromEdge = 0.6; const unitsLabelOffset = 0.5;
                const hL = length / 2; const plotEdgeZ = -hL; const wT = [];
                for (let i = 0; i <= width; i += subdivisions) {
                    const xP = -width / 2 + i;
                    if (Math.abs(i - Math.round(i)) < 0.001) {
                        wT.push(new THREE.Vector3(xP, 0, plotEdgeZ), new THREE.Vector3(xP, 0, plotEdgeZ - majorTickLength));
                        this.container.add(this._createTextSprite(Math.round(i * cF).toString(), new THREE.Vector3(xP, 0, plotEdgeZ - textOffsetFromEdge), theme.text));
                    } else { wT.push(new THREE.Vector3(xP, 0, plotEdgeZ), new THREE.Vector3(xP, 0, plotEdgeZ - minorTickLength)); }
                }
                this.container.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(wT), new THREE.LineBasicMaterial({ color: theme.text, transparent: true })));
                this.container.add(this._createTextSprite(`(${unitSymbol})`, new THREE.Vector3(width / 2 + unitsLabelOffset, 0, plotEdgeZ - textOffsetFromEdge), theme.text));
                const hW = width / 2; const plotEdgeX = -hW; const lT = [];
                for (let i = 0; i <= length; i += subdivisions) {
                    const zP = -length / 2 + i;
                    if (Math.abs(i - Math.round(i)) < 0.001) {
                        lT.push(new THREE.Vector3(plotEdgeX, 0, zP), new THREE.Vector3(plotEdgeX - majorTickLength, 0, zP));
                        const tS = this._createTextSprite(Math.round(i * cF).toString(), new THREE.Vector3(plotEdgeX - textOffsetFromEdge, 0, zP), theme.text);
                        tS.center.set(1.0, 0.5); this.container.add(tS);
                    } else { lT.push(new THREE.Vector3(plotEdgeX, 0, zP), new THREE.Vector3(plotEdgeX - minorTickLength, 0, zP)); }
                }
                this.container.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(lT), new THREE.LineBasicMaterial({ color: theme.text, transparent: true })));
                this.container.add(this._createTextSprite(`(${unitSymbol})`, new THREE.Vector3(plotEdgeX - textOffsetFromEdge, 0, length / 2 + unitsLabelOffset), theme.text));
            }
        }

        class ControlsPanel {
            constructor(world) {
                this.world = world;
                this.pane = new Tweakpane.Pane({ title: 'Allotment Controls', container: document.querySelector('#main-controls-container') });
                this.config = {
                    units: 'm', width: 10, length: 15,
                    gridVisible: true, rulersVisible: true, snapToGrid: true,
                    darkMode: false, subdivisions: 1.0,
                    gridOpacity: 0.3, rulerOpacity: 1.0, viewLocked: false,
                    showLabels: false,
                    isometricZoom: 1.0,
                    timeOfDay: 12.0, // NEW: Time of day (noon)
                    showAxisIndicator: true,
                };
                const plotFolder = this.pane.addFolder({ title: 'Plot Dimensions' });
                const unitOptions = Object.keys(UNITS).reduce((acc, key) => { acc[UNITS[key].label] = key; return acc; }, {});
                plotFolder.addInput(this.config, 'units', { options: unitOptions }).on('change', (ev) => this.onUnitsChange(ev.value));
                this.widthInput = plotFolder.addInput(this.config, 'width', { label: 'Width (m)', min: 1, max: 100, step: 1 });
                this.lengthInput = plotFolder.addInput(this.config, 'length', { label: 'Length (m)', min: 1, max: 100, step: 1 });
                this.widthInput.on('change', () => this.updatePlotFromUI()); this.lengthInput.on('change', () => this.updatePlotFromUI());

                this.viewFolder = this.pane.addFolder({ title: 'View Options' });
                this.subdivisionInput = null; this.updateSubdivisionInput();

                // NEW: Time of Day slider
                this.viewFolder.addInput(this.config, 'timeOfDay', { label: 'Time of Day', min: 5, max: 21, step: 0.1 })
                    .on('change', (ev) => this.world.updateSunPosition(ev.value));

                this.viewFolder.addInput(this.config, 'gridVisible').on('change', (ev) => this.world.setGridVisible(ev.value));
                this.viewFolder.addInput(this.config, 'gridOpacity', { min: 0, max: 1, step: 0.05 }).on('change', (ev) => this.world.setGridOpacity(ev.value));
                this.viewFolder.addInput(this.config, 'rulersVisible').on('change', (ev) => this.world.setRulersVisible(ev.value));
                this.viewFolder.addInput(this.config, 'rulerOpacity', { min: 0, max: 1, step: 0.05 }).on('change', (ev) => this.world.setRulerOpacity(ev.value));
                this.viewFolder.addInput(this.config, 'darkMode').on('change', (ev) => this.world.setTheme(ev.value));
                this.viewFolder.addInput(this.config, 'showLabels', { label: 'Show Labels' }).on('change', (ev) => this.world.updateAllObjectLabelsVisibility());
                this.viewFolder.addInput(this.config, 'showAxisIndicator', { label: 'Show Axis Indicator' }).on('change', (ev) => this.world.toggleAxisIndicator(ev.value));
                this.viewFolder.addButton({ title: 'Plant Summary' }).on('click', () => this.world.togglePlantSummaryPanel());
                this.viewFolder.addButton({ title: 'Top-Down View' }).on('click', () => this.world.goToTopView());
                this.viewFolder.addButton({ title: 'Isometric View' }).on('click', () => this.world.goToIsometricView());
                this.viewFolder.addInput(this.config, 'isometricZoom', { label: 'Isometric Zoom', min: 0.1, max: 5.0, step: 0.1 })
                    .on('change', () => this.world._updateIsometricCameraPosition());
                this.viewFolder.addInput(this.config, 'viewLocked', { label: 'Lock View' }).on('change', (ev) => this.world.setViewLock(ev.value));

                const interactionFolder = this.pane.addFolder({ title: 'Interaction' });
                interactionFolder.addInput(this.config, 'snapToGrid');
            }

            updateSubdivisionInput() {
                if (this.subdivisionInput) this.subdivisionInput.dispose();
                const currentSystem = UNITS[this.config.units].system;
                const newOptions = currentSystem === 'metric' ? METRIC_SUBDIVISIONS : IMPERIAL_SUBDIVISIONS;
                if (!Object.values(newOptions).includes(this.config.subdivisions)) {
                    this.config.subdivisions = currentSystem === 'metric' ? 1.0 : 0.3048;
                }
                this.subdivisionInput = this.viewFolder.addInput(this.config, 'subdivisions', { label: 'Subdivisions', options: newOptions });
                this.subdivisionInput.on('change', () => this.updatePlotFromUI());
                this.pane.refresh();
            }

            onUnitsChange(newUnitsKey) {
                const oldUnitsKey = this.config.units;
                const newUnitInfo = UNITS[newUnitsKey];
                const widthInMeters = convertToMeters(this.config.width, oldUnitsKey);
                const lengthInMeters = convertToMeters(this.config.length, oldUnitsKey);
                this.config.width = parseFloat(convertFromMeters(widthInMeters, newUnitsKey).toFixed(1));
                this.config.length = parseFloat(convertFromMeters(lengthInMeters, newUnitsKey).toFixed(1));
                this.config.units = newUnitsKey;
                this.widthInput.label = `Width (${newUnitInfo.symbol})`;
                this.lengthInput.label = `Length (${newUnitInfo.symbol})`;
                this.updateSubdivisionInput();
                this.pane.refresh();
                this.updatePlotFromUI();
                this.world.updatePlantSummaryPanel();
                if (this.world.selectedObject) { // <-- ADD THIS BLOCK
                    this.world._updateDimensionLabels();
                }
                this.world.undoManager.saveState(); // Save state on unit change
            }
            updatePlotFromUI() {
                const widthInMeters = convertToMeters(this.config.width, this.config.units);
                const lengthInMeters = convertToMeters(this.config.length, this.config.units);
                this.world.updatePlot(widthInMeters, lengthInMeters, this.config.units, this.config.subdivisions);
            }
        }

        class Sidebar {
            constructor(world) {
                this.world = world;
                this.selectedItem = null;
                
                // NEW: Create and prepend search input
                const sidebarContainer = document.querySelector('#sidebar-container');
                this.searchInput = document.createElement('input');
                this.searchInput.id = 'sidebar-search-input';
                this.searchInput.type = 'text';
                this.searchInput.placeholder = 'Search...';
                sidebarContainer.prepend(this.searchInput);

                // Create Tweakpane in its own dedicated container
                this.paneContainer = document.querySelector('#sidebar-pane-container');
                this.pane = new Tweakpane.Pane({
                    container: this.paneContainer,
                });
                // Remove the title from the pane itself as the panel has one
                this.pane.title = "Placeables";
                
                this.allButtons = [];
                this.allFolders = [];

                const structuresFolder = this.pane.addFolder({ title: 'Structures', expanded: true });
                this.allFolders.push(structuresFolder);
                STRUCTURES.forEach(item => {
                    const button = structuresFolder.addButton({ title: item.name });
                    button.on('click', () => {
                        this.selectedItem = item;
                        this.world.enterPlacementMode(item);
                    });
                    this.allButtons.push({ element: button.element, title: item.name.toLowerCase(), folder: structuresFolder });
                });

                for (const category in PLANTS) {
                    const categoryFolder = this.pane.addFolder({ title: category.charAt(0).toUpperCase() + category.slice(1), expanded: false });
                    this.allFolders.push(categoryFolder);
                    PLANTS[category].forEach(plantDef => {
                        const button = categoryFolder.addButton({ title: plantDef.name });
                        button.on('click', () => {
                            this.selectedItem = plantDef;
                            this.world.enterPlacementMode(plantDef);
                        });
                        this.allButtons.push({ element: button.element, title: plantDef.name.toLowerCase(), folder: categoryFolder });
                    });
                }
                
                this.searchInput.addEventListener('input', (e) => this.filterItems(e.target.value));
            }
            
            filterItems(query) {
                const normalizedQuery = query.toLowerCase().trim();
                
                this.allButtons.forEach(btn => {
                    const isVisible = btn.title.includes(normalizedQuery);
                    btn.element.style.display = isVisible ? 'block' : 'none';
                });
                
                this.allFolders.forEach(folder => {
                    const hasVisibleButton = this.allButtons.some(btn => btn.folder === folder && btn.element.style.display !== 'none');
                    folder.element.style.display = hasVisibleButton ? 'block' : 'none';
                });
            }

            deselect() {
                this.selectedItem = null;
            }
        }

        class InfoPanel {
            constructor() {
                this.panel = document.querySelector('#info-panel'); this.title = document.querySelector('#info-title');
                this.details = document.querySelector('#info-details'); this.button = document.querySelector('#info-button');
                this.button.onclick = null;
                this.button.addEventListener('click', () => this.hide());
            }
            show(title, details, buttonConfig) {
                this.title.textContent = title; this.details.textContent = details;
                this.button.onclick = null;
                if (buttonConfig && buttonConfig.onClick) {
                    this.button.textContent = buttonConfig.text;
                    this.button.style.display = 'inline-block';
                    this.button.onclick = buttonConfig.onClick;
                } else {
                    this.button.textContent = 'OK';
                    this.button.style.display = 'inline-block';
                    this.button.onclick = () => this.hide();
                }
                this.panel.classList.remove('hidden');
            }
            hide() { this.panel.classList.add('hidden'); }
        }

        function disposeObject(obj) {
            if (!obj) return;
            if (obj.children) {
                [...obj.children].forEach(disposeObject);
            }
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(mat => { if (mat.map) mat.map.dispose(); mat.dispose(); });
                } else {
                    if (obj.material.map) obj.material.map.dispose();
                    obj.material.dispose();
                }
            }
        }

        class World {
            constructor(container) {
                this.camera = createCamera(); this.scene = createScene(); this.renderer = createRenderer();
                container.append(this.renderer.domElement);
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.minDistance = 0.5;
                this.plot = createPlot(); this.rulers = new Rulers();
                this.scene.add(this.plot.ground, this.plot.grid, this.rulers.container);

                const { hemiLight, sunLight } = createLights();
                this.hemiLight = hemiLight;
                this.sunLight = sunLight;
                this.scene.add(this.hemiLight, this.sunLight, this.sunLight.target);
                
                this.loop = new Loop(this.camera, this.scene, this.renderer); this.loop.updatables.push(this.controls);

                this.currentTheme = 'light';
                this.controlsPanel = new ControlsPanel(this);
                this.sidebar = new Sidebar(this);
                this.infoPanel = new InfoPanel();
                this.rightToolPanelContainer = document.querySelector('#right-tool-panel-container');
                
                this.plantSummaryPanel = document.querySelector('#plant-summary-panel');

                this.undoManager = new UndoManager(this); // NEW: Initialize UndoManager

                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
                this.mode = 'IDLE';
                this.isPlacementValid = false;
                this.validPlacementColor = new THREE.Color(0x5a8e3b);
                this.invalidPlacementColor = new THREE.Color(0xdc3545);
                this.fenceStartPoint = null; // New property for two-click fence placement

                this.placedObjects = [];
                this.selectedObject = null;
                this.selectedPlantInPlanter = null;
                this.objectToMove = null;
                this.originalPosition = null;
                this.placementRotation = 0;

                this.selectionBox = null; this.selectionBoxUpdater = null;
                this.plantSelectionBox = null; this.plantSelectionBoxUpdater = null;
                this.placementPreview = null;
                this.plantPlacementPreview = null;
                this.planterGridHelper = null;

                this.activeToolPane = null;

                this.activePlanter = null;
                this.plantToPlaceInPlanterConfig = null;
                this.temporaryPlacementConfig = null;
                this.randomPopulateConfig = { count: 5 };

                this.activePlanterHistory = [];
                this.MAX_PLANTER_HISTORY = 5;

                this.isometricViewAngle = Math.PI / 4;
                this.baseIsometricDistanceFactor = 2.5;

                this.showLabels = false;
                this.allObjectLabels = new THREE.Group();
                this.scene.add(this.allObjectLabels);
                this.labelSprites = new Map();
                this.loop.updatables.push(this);
                
                this.debugBoxHelper = null; 
                this.debugBoxHelperUpdater = null; 
                
                // Add dimension label group
                this.dimensionLabelGroup = new THREE.Group();
                this.dimensionLabelGroup.visible = false;
                this.scene.add(this.dimensionLabelGroup);
                this.dimensionLabels = new Map(); // Store dimension label sprites
                
                // Perimeter Builder properties
                this.perimeterPathPoints = [];
                this.perimeterGateSegments = [];
                this.perimeterPathLine = null;
                this.perimeterGateLine = null;
                this.perimeterBuilderPane = null;
                

                
                // Snap marker for fence drawing
                this.snapMarker = null;
                
                // Perimeter Fence Generator properties
                this.perimeterConfig = {
                    topEdge: true,
                    topGate_Left: false,
                    topGate_Center: false,
                    topGate_Right: false,
                    bottomEdge: true,
                    bottomGate_Left: false,
                    bottomGate_Center: false,
                    bottomGate_Right: false,
                    leftEdge: true,
                    leftGate_Left: false,
                    leftGate_Center: false,
                    leftGate_Right: false,
                    rightEdge: true,
                    rightGate_Left: false,
                    rightGate_Center: false,
                    rightGate_Right: false,
                };
                this.perimeterPane = null;
                
                // Initialize 3D Axis Indicator
                this.axisIndicatorContainer = document.getElementById('axis-indicator-container');
                this.axisIndicator = new AxisIndicator(this.axisIndicatorContainer);
                this.axisIndicatorVisible = true;
                // --- OPTIMIZATION: Track last camera quaternion for axis indicator updates ---
                this._lastAxisIndicatorQuat = new THREE.Quaternion();
                
                this.createBackgroundAndClouds(); 
                this.setTheme(this.controlsPanel.config.darkMode);
                this.setViewLock(this.controlsPanel.config.viewLocked);
                this.addEventListeners();
                this.onResize();
                this.resizeHandles = new ResizeHandles(this, this.camera, this.renderer.domElement, this.controls, this.updateObjectDimensions.bind(this));
                this.scene.add(this.resizeHandles.handles);
                this.loop.updatables.push(this.resizeHandles);
                
                // Add 3D axis labels to the plot
                this.axisWidgetGroup = new THREE.Group();
                this.scene.add(this.axisWidgetGroup);
                this.addPlotAxisWidget();

                this.isShiftDown = false;
                window.addEventListener('keydown', (e) => { if (e.key === 'Shift') this.isShiftDown = true; });
                window.addEventListener('keyup', (e) => { if (e.key === 'Shift') this.isShiftDown = false; });
            }

            start() {
                // --- OPTIMIZATION: Use custom animation loop for axis indicator update ---
                const animate = () => {
                    this.loop.tick();
                    this.renderer.render(this.scene, this.camera);
                    // Only update axis indicator if camera orientation changed
                    if (this.axisIndicator && this.axisIndicatorVisible) {
                        if (!this.camera.quaternion.equals(this._lastAxisIndicatorQuat)) {
                            this.axisIndicator.update(this.camera);
                            this._lastAxisIndicatorQuat.copy(this.camera.quaternion);
                        }
                    }
                    requestAnimationFrame(animate);
                };
                animate();
                this.undoManager.saveState(); // Save initial state
            }
            update() { 
                this.addPlotAxisWidget();
                this.updateLoopLabels(); 
                this._updateDimensionLabelPositions();
                // Make axis labels always face the camera
                if (this.axisWidgetGroup && this.axisWidgetGroup.children.length > 0) {
                    for (const child of this.axisWidgetGroup.children) {
                        if (child.isSprite) child.quaternion.copy(this.camera.quaternion);
                    }
                }
            }

            createCloudTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.fillStyle = gradient;
                for (let i = 0; i < 5; i++) {
                    context.beginPath();
                    const x = Math.random() * canvas.width * 0.7 + canvas.width * 0.15;
                    const y = Math.random() * canvas.height * 0.5 + canvas.height * 0.25;
                    const r = Math.random() * canvas.height * 0.3 + canvas.height * 0.1;
                    context.arc(x, y, r, 0, Math.PI * 2);
                    context.fill();
                }
                return new THREE.CanvasTexture(canvas);
            }

            createBackgroundAndClouds() {
                const skyGeometry = new THREE.SphereGeometry(500, 32, 16);
                const skyMaterial = new THREE.ShaderMaterial({
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize( vWorldPosition + offset ).y;
                            gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
                        }
                    `,
                    uniforms: {
                        topColor: { value: new THREE.Color(THEMES.light.gradientTop) },
                        bottomColor: { value: new THREE.Color(THEMES.light.gradientBottom) },
                        offset: { value: 0 },
                        exponent: { value: 0.6 }
                    },
                    side: THREE.BackSide
                });
                this.skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(this.skyDome);

                this.cloudGroup = new THREE.Group();
                this.scene.add(this.cloudGroup);
                const cloudTexture = this.createCloudTexture();
                const cloudCount = 25;
                this.cloudBounds = { x: 200, z: 150 };
                for (let i = 0; i < cloudCount; i++) {
                    const cloudMaterial = new THREE.SpriteMaterial({
                        map: cloudTexture,
                        color: 0xffffff,
                        transparent: true,
                        opacity: Math.random() * 0.4 + 0.5,
                        depthWrite: false
                    });
                    const cloud = new THREE.Sprite(cloudMaterial);
                    this.cloudGroup.add(cloud);
                    const scale = Math.random() * 20 + 20;
                    cloud.scale.set(scale * 1.5, scale, 1);
                    cloud.position.set(
                        (Math.random() - 0.5) * this.cloudBounds.x * 2,
                        Math.random() * 10 + 20, // LOWERED clouds: was Math.random() * 20 + 40
                        (Math.random() - 0.5) * this.cloudBounds.z * 2 - 50
                    );
                    cloud.userData.speed = (Math.random() * 0.05 + 0.02) * (Math.random() < 0.5 ? 1 : -1);
                    this.loop.updatables.push({
                        update: (delta) => {
                            cloud.position.x += cloud.userData.speed * delta * 20;
                            if (cloud.userData.speed > 0 && cloud.position.x > this.cloudBounds.x) {
                                cloud.position.x = -this.cloudBounds.x;
                            } else if (cloud.userData.speed < 0 && cloud.position.x < -this.cloudBounds.x) {
                                cloud.position.x = this.cloudBounds.x;
                            }
                        }
                    });
                }
            }


            addEventListeners() {
                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousedown', (event) => this.onMouseDown(event), true);
                window.addEventListener('mouseup', (event) => this.onMouseUp(event), true);
                window.addEventListener('click', (event) => this.onMouseClick(event), true);
                window.addEventListener('mousemove', (event) => this.onMouseMove(event));
                window.addEventListener('keydown', (event) => this.onKeyDown(event));
                
                // --- START: Added Event Listeners for Save/Load panel ---
                document.getElementById('saveLayoutBtn').addEventListener('click', () => this.saveLayout());
                document.getElementById('loadLayoutBtn').addEventListener('click', () => this.loadLayout());
                document.getElementById('exportLayoutBtn').addEventListener('click', () => this.exportLayout());
                document.getElementById('importFile').addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = JSON.parse(e.target.result);
                                this.rebuildSceneFromData(data, "Imported");
                            } catch (error) {
                                this.infoPanel.show("Import Failed", "Invalid JSON file.", { text: "OK" });
                                console.error("JSON Parse Error:", error);
                            }
                        };
                        reader.readAsText(file);
                    }
                    event.target.value = ''; // Reset file input
                });
                document.getElementById('randomizeLayoutBtn').addEventListener('click', () => this.randomizeLayout());
                document.getElementById('clearAllBtn').addEventListener('click', () => this.confirmAndClearAll());
                document.getElementById('perimeterFenceBtn').addEventListener('click', () => this.togglePerimeterPanel());
                document.getElementById('exportPlantSummaryBtn').addEventListener('click', () => this.exportPlantSummary());
                // --- END: Added Event Listeners ---
            }

            updatePlot(width, length, unitsKey, subdivisions) {
                const theme = THEMES[this.currentTheme];
                this.plot.ground.scale.set(width, 1, length);
                this.plot.ground.material.color.set(theme.ground);
                this.updateCustomGrid(width, length, theme, subdivisions);
                this.rulers.update(width, length, unitsKey, theme, subdivisions);
                this.setGridVisible(this.controlsPanel.config.gridVisible);
                this.setRulersVisible(this.controlsPanel.config.rulersVisible);
                this.setGridOpacity(this.controlsPanel.config.gridOpacity);
                this.setRulerOpacity(this.controlsPanel.config.rulerOpacity);
            }

            updateCustomGrid(width, length, theme, subdivisions) {
                if (this.plot.grid) {
                    disposeObject(this.plot.grid);
                    this.scene.remove(this.plot.grid);
                }
                const points = []; const halfW = width / 2; const halfL = length / 2;
                for (let i = 0; i <= width; i += subdivisions) {
                    const x = -halfW + i;
                    points.push(new THREE.Vector3(x, 0, -halfL), new THREE.Vector3(x, 0, halfL));
                }
                for (let i = 0; i <= length; i += subdivisions) {
                    const z = -halfL + i;
                    points.push(new THREE.Vector3(-halfW, 0, z), new THREE.Vector3(halfW, 0, z));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: theme.grid, transparent: true });
                this.plot.grid = new THREE.LineSegments(geometry, material);
                this.plot.grid.position.y = 0.001;
                this.scene.add(this.plot.grid);
            }

            createPlanterMeshes(outerWidth, outerDepth, outerHeight, wallThickness, soilHeight, wallMaterialProps, soilMaterialProps) {
                const planterGroup = new THREE.Group();
                const innerWidth = outerWidth - 2 * wallThickness;
                const innerDepth = outerDepth - 2 * wallThickness;
                const wallMaterial = new THREE.MeshStandardMaterial(wallMaterialProps);

                const bottomHeight = wallThickness;
                const bottomGeom = new THREE.BoxGeometry(outerWidth, bottomHeight, outerDepth);
                const bottomMesh = new THREE.Mesh(bottomGeom, wallMaterial);
                bottomMesh.position.y = bottomHeight / 2;

                planterGroup.add(bottomMesh);

                const wallGeomHeight = outerHeight - bottomHeight;
                if (wallGeomHeight > 0.001) {
                    const wallY = bottomHeight + (wallGeomHeight / 2);
                    const fbWallGeom = new THREE.BoxGeometry(outerWidth, wallGeomHeight, wallThickness);
                    const frontWall = new THREE.Mesh(fbWallGeom, wallMaterial);
                    frontWall.position.set(0, wallY, (outerDepth - wallThickness) / 2);
                    planterGroup.add(frontWall);
                    const backWall = new THREE.Mesh(fbWallGeom.clone(), wallMaterial);
                    backWall.position.set(0, wallY, -(outerDepth - wallThickness) / 2);
                    planterGroup.add(backWall);
                    const lrWallGeom = new THREE.BoxGeometry(wallThickness, wallGeomHeight, innerDepth);
                    const leftWall = new THREE.Mesh(lrWallGeom, wallMaterial);
                    leftWall.position.set(-(innerWidth + wallThickness) / 2, wallY, 0);
                    planterGroup.add(leftWall);
                    const rightWall = new THREE.Mesh(lrWallGeom.clone(), wallMaterial);
                    rightWall.position.set((innerWidth + wallThickness) / 2, wallY, 0);
                    planterGroup.add(rightWall);
                }

                const clampedSoilHeight = Math.min(soilHeight, wallGeomHeight);
                if (clampedSoilHeight > 0.001) {
                    const soilGeom = new THREE.BoxGeometry(innerWidth, clampedSoilHeight, innerDepth);
                    const soilMat = new THREE.MeshStandardMaterial(soilMaterialProps || { color: 0x6B4226 });
                    const soilMesh = new THREE.Mesh(soilGeom, soilMat);
                    soilMesh.position.y = bottomHeight + clampedSoilHeight / 2;
                    soilMesh.name = 'planterSoil';
                    planterGroup.add(soilMesh);
                    planterGroup.userData.innerDimensions = { width: innerWidth, depth: innerDepth, height: clampedSoilHeight };
                }

                planterGroup.userData.isPlanter = true;
                return planterGroup;
            }

            /**
             * --- ENHANCED PLANT MESH CREATION ---
             * Creates a Three.js Group representing a plant.
             * Now generates a more detailed procedural model for trees.
             * @param {object} plantDef - Plant definition including dimensions, material, growth.
             * @returns {THREE.Group}
             */
            createPlantMesh(plantDef) {
                if (plantDef.originalWidth === undefined) {
                    plantDef.originalWidth = plantDef.width;
                    plantDef.originalDepth = plantDef.depth;
                    plantDef.originalHeight = plantDef.height;
                }

                const growth = plantDef.growth || 1.0;
                const effectiveWidth = plantDef.originalWidth * growth;
                const effectiveDepth = plantDef.originalDepth * growth;
                const effectiveHeight = plantDef.originalHeight * growth;
                
                const plantGroup = new THREE.Group();
                const visualMat = new THREE.MeshStandardMaterial(plantDef.materialProps);

                // Check for tree-like plants to give them a better model
                const isTreeLike = plantDef.name.toLowerCase().includes('tree') || ['dwarf apple', 'pears', 'plums', 'cherries', 'figs'].includes(plantDef.name.toLowerCase());

                if (isTreeLike && effectiveHeight > 0.5) {
                    // --- Procedural Tree Model ---
                    const trunkHeight = effectiveHeight * 0.6;
                    const trunkRadius = effectiveWidth * 0.1;
                    const canopyHeight = effectiveHeight * 0.5;
                    const canopyRadius = effectiveWidth / 2;

                    // Trunk
                    const trunkGeom = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 8);
                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                    const trunkMesh = new THREE.Mesh(trunkGeom, trunkMat);
                    trunkMesh.position.y = trunkHeight / 2;
                    plantGroup.add(trunkMesh);

                    // Canopy (Leaves)
                    const canopyGeom = new THREE.SphereGeometry(canopyRadius, 8, 6);
                    const canopyMesh = new THREE.Mesh(canopyGeom, visualMat);
                    canopyMesh.position.y = trunkHeight + canopyHeight * 0.2; // Position canopy on top of trunk
                    plantGroup.add(canopyMesh);
                    
                } else {
                    // --- Default Plant Model (Box) ---
                    const visualGeom = new THREE.BoxGeometry(effectiveWidth, effectiveHeight, effectiveDepth);
                    const plantVisual = new THREE.Mesh(visualGeom, visualMat);
                    plantVisual.position.y = effectiveHeight / 2;
                    plantGroup.add(plantVisual);
                }

                plantGroup.name = plantDef.name;
                plantGroup.userData.isPlant = true;
                plantGroup.userData.dimensions = {
                    ...plantDef,
                    width: effectiveWidth,
                    depth: effectiveDepth,
                    height: effectiveHeight,
                    growth
                };
                return plantGroup;
            }

            createBasicStructureMesh(itemData) {
                const geom = new THREE.BoxGeometry(itemData.width, itemData.height, itemData.depth);
                const mat = new THREE.MeshStandardMaterial(itemData.materialProps);
                const mesh = new THREE.Mesh(geom, mat);
                const group = new THREE.Group();
                group.add(mesh);
                mesh.position.y = itemData.height / 2;
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createPitchedRoof(roofBaseWidth, roofDepth, peakRise, material, overhangX = 0.1, overhangZ = 0.05) {
                if (peakRise <= 0) {
                    const flatRoofGeom = new THREE.BoxGeometry(roofBaseWidth + overhangX * 2, 0.05, roofDepth + overhangZ * 2);
                    const flatRoofMesh = new THREE.Mesh(flatRoofGeom, material);
                    flatRoofMesh.position.y = 0.05 / 2;
                    return flatRoofMesh;
                }
                const halfRoofBaseWidth = roofBaseWidth / 2;
                const roofShape = new THREE.Shape();
                roofShape.moveTo(-halfRoofBaseWidth - overhangX, 0);
                roofShape.lineTo( halfRoofBaseWidth + overhangX, 0);
                roofShape.lineTo(0, peakRise);
                roofShape.lineTo(-halfRoofBaseWidth - overhangX, 0);
                const extrudeSettings = { steps: 1, depth: roofDepth + overhangZ * 2, bevelEnabled: false };
                const roofGeometry = new THREE.ExtrudeGeometry(roofShape, extrudeSettings);
                const roofMesh = new THREE.Mesh(roofGeometry, material);
                roofMesh.geometry.computeBoundingBox();
                const bbox = roofMesh.geometry.boundingBox;
                roofMesh.position.x = - (bbox.max.x + bbox.min.x) / 2;
                roofMesh.position.y = - bbox.min.y;
                roofMesh.position.z = - (bbox.max.z + bbox.min.z) / 2;
                return roofMesh;
            }


            createShedMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                const wallHeight = itemData.height * 0.75;
                const roofPeakHeight = itemData.height;
                const peakRise = roofPeakHeight - wallHeight;
                const bodyGeom = new THREE.BoxGeometry(itemData.width, wallHeight, itemData.depth);
                const bodyMesh = new THREE.Mesh(bodyGeom, material);
                bodyMesh.position.y = wallHeight / 2;
                group.add(bodyMesh);
                const roofMaterial = new THREE.MeshStandardMaterial({ color: material.color.clone().multiplyScalar(0.7), roughness: 0.95 });
                const roof = this.createPitchedRoof(itemData.width, itemData.depth, peakRise, roofMaterial, 0.1, 0.05);
                roof.position.y = wallHeight;
                group.add(roof);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createGreenhouseMesh(itemData) {
                const group = new THREE.Group();
                const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                const glassMaterial = new THREE.MeshStandardMaterial({
                    ...itemData.materialProps,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                });
                const frameThickness = 0.05;
                const wallHeight = itemData.height * 0.7;
                const roofPeakHeight = itemData.height;
                const peakRise = roofPeakHeight - wallHeight;
                const halfWidth = itemData.width / 2;
                const halfDepth = itemData.depth / 2;
                const wallGroup = new THREE.Group();
                const fbWallGeom = new THREE.BoxGeometry(itemData.width, wallHeight, frameThickness);
                const frontWall = new THREE.Mesh(fbWallGeom, glassMaterial);
                frontWall.position.set(0, wallHeight / 2, halfDepth - frameThickness / 2);
                wallGroup.add(frontWall);
                const backWall = frontWall.clone();
                backWall.position.z = -halfDepth + frameThickness / 2;
                wallGroup.add(backWall);
                const lrWallGeom = new THREE.BoxGeometry(frameThickness, wallHeight, itemData.depth - 2 * frameThickness);
                const leftWall = new THREE.Mesh(lrWallGeom, glassMaterial);
                leftWall.position.set(-halfWidth + frameThickness / 2, wallHeight / 2, 0);
                wallGroup.add(leftWall);
                const rightWall = leftWall.clone();
                rightWall.position.x = halfWidth - frameThickness / 2;
                wallGroup.add(rightWall);
                group.add(wallGroup);
                const glassRoof = this.createPitchedRoof(itemData.width, itemData.depth, peakRise, glassMaterial, 0, 0);
                glassRoof.position.y = wallHeight;
                group.add(glassRoof);
                const postGeom = new THREE.BoxGeometry(frameThickness, wallHeight, frameThickness);
                const postY = wallHeight / 2;
                const postPositions = [
                    new THREE.Vector3(halfWidth - frameThickness / 2, postY, halfDepth - frameThickness / 2),
                    new THREE.Vector3(-halfWidth + frameThickness / 2, postY, halfDepth - frameThickness / 2),
                    new THREE.Vector3(halfWidth - frameThickness / 2, postY, -halfDepth + frameThickness / 2),
                    new THREE.Vector3(-halfWidth + frameThickness / 2, postY, -halfDepth + frameThickness / 2)
                ];
                postPositions.forEach(pos => {
                    const post = new THREE.Mesh(postGeom, frameMaterial);
                    post.position.copy(pos);
                    group.add(post);
                });

                // --- START OF FIX ---
                const fbRailGeom = new THREE.BoxGeometry(itemData.width, frameThickness, frameThickness);
                const lrRailGeom = new THREE.BoxGeometry(frameThickness, frameThickness, itemData.depth);
                const eaveY = wallHeight - frameThickness / 2;
                const baseY = frameThickness / 2;
                const railPositions = [
                    { geom: fbRailGeom, pos: new THREE.Vector3(0, eaveY, halfDepth - frameThickness / 2) },
                    { geom: fbRailGeom, pos: new THREE.Vector3(0, eaveY, -halfDepth + frameThickness / 2) },
                    { geom: lrRailGeom, pos: new THREE.Vector3(halfWidth - frameThickness / 2, eaveY, 0) },
                    { geom: lrRailGeom, pos: new THREE.Vector3(-halfWidth + frameThickness / 2, eaveY, 0) },
                    { geom: fbRailGeom, pos: new THREE.Vector3(0, baseY, halfDepth - frameThickness / 2) },
                    { geom: fbRailGeom, pos: new THREE.Vector3(0, baseY, -halfDepth + frameThickness / 2) },
                    { geom: lrRailGeom, pos: new THREE.Vector3(halfWidth - frameThickness / 2, baseY, 0) },
                    { geom: lrRailGeom, pos: new THREE.Vector3(-halfWidth + frameThickness / 2, baseY, 0) },
                ];

                railPositions.forEach(r => {
                    const railMesh = new THREE.Mesh(r.geom, frameMaterial);
                    railMesh.position.copy(r.pos);
                    group.add(railMesh);
                });
                // --- END OF FIX ---
                
                const ridgeBeam = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, frameThickness, itemData.depth), frameMaterial);
                ridgeBeam.position.set(0, roofPeakHeight - frameThickness / 2, 0);
                group.add(ridgeBeam);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }


            createWaterButtMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                const radius = itemData.width / 2;
                const height = itemData.height;
                const cylinderGeom = new THREE.CylinderGeometry(radius, radius, height, 32);
                const cylinderMesh = new THREE.Mesh(cylinderGeom, material);
                cylinderMesh.position.y = height / 2;
                group.add(cylinderMesh);
                const waterLevelHeight = height * 0.4;
                const waterGeom = new THREE.CylinderGeometry(radius * 0.95, radius * 0.95, waterLevelHeight, 32);
                const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, transparent: true, opacity: 0.7 });
                const waterMesh = new THREE.Mesh(waterGeom, waterMaterial);
                waterMesh.position.y = waterLevelHeight / 2 + 0.01;
                group.add(waterMesh);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createFenceSectionMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                
                const postThickness = 0.1; 
                const height = itemData.height;
                const width = itemData.width;

                // Build geometry with its base at Y=0 (pivot at center)
                const postGeom = new THREE.BoxGeometry(postThickness, height, postThickness);

                // Create posts. Their pivot is at their center, so we position them at half their height.
                const postY = height / 2;

                // Always create end posts
                const leftPost = new THREE.Mesh(postGeom, material);
                leftPost.position.set(-width / 2 + postThickness / 2, postY, 0);
                group.add(leftPost);

                const rightPost = new THREE.Mesh(postGeom, material);
                rightPost.position.set(width / 2 - postThickness / 2, postY, 0);
                group.add(rightPost);
                
                // Add intermediate posts every 2 meters for longer fences
                const maxPostSpacing = 2.0; // Maximum distance between posts
                const numIntermediatePosts = Math.floor((width - maxPostSpacing) / maxPostSpacing);
                
                for (let i = 1; i <= numIntermediatePosts; i++) {
                    const postX = -width / 2 + (i * maxPostSpacing);
                    if (postX < width / 2 - postThickness) { // Ensure post doesn't overlap with right end post
                        const intermediatePost = new THREE.Mesh(postGeom, material);
                        intermediatePost.position.set(postX, postY, 0);
                        group.add(intermediatePost);
                    }
                }

                // Create rails
                const railWidth = width; // Rails span the full width
                const railGeom = new THREE.BoxGeometry(railWidth, postThickness, postThickness);

                const topRail = new THREE.Mesh(railGeom, material);
                topRail.position.set(0, height * 0.8, 0); // Y position is relative to the y=0 base
                group.add(topRail);

                const bottomRail = new THREE.Mesh(railGeom, material);
                bottomRail.position.set(0, height * 0.2, 0); // Y position is relative to the y=0 base
                group.add(bottomRail);

                // Keep the group's pivot at center (no adjustment needed)
                // This ensures the fence is perfectly centered and doesn't clip through the ground

                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createGateMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                const frameThickness = itemData.depth;
                const stileHeight = itemData.height;
                const stileWidth = frameThickness;
                const stileGeom = new THREE.BoxGeometry(stileWidth, stileHeight, stileWidth);
                const leftStile = new THREE.Mesh(stileGeom, material);
                leftStile.position.set(-itemData.width / 2 + stileWidth / 2, stileHeight / 2, 0);
                group.add(leftStile);
                const rightStile = new THREE.Mesh(stileGeom.clone(), material);
                rightStile.position.set(itemData.width / 2 - stileWidth / 2, stileHeight / 2, 0);
                group.add(rightStile);
                const railWidth = itemData.width - (2 * stileWidth);
                const railHeight = frameThickness;
                const railGeom = new THREE.BoxGeometry(railWidth, railHeight, frameThickness);
                const topRail = new THREE.Mesh(railGeom, material);
                topRail.position.set(0, itemData.height - railHeight / 2, 0);
                group.add(topRail);
                const midRail = new THREE.Mesh(railGeom.clone(), material);
                midRail.position.set(0, itemData.height / 2, 0);
                group.add(midRail);
                const bottomRail = new THREE.Mesh(railGeom.clone(), material);
                bottomRail.position.set(0, railHeight / 2, 0);
                group.add(bottomRail);
                const effectiveBraceWidth = itemData.width - (2 * stileWidth);
                const effectiveBraceHeight = itemData.height;
                const braceLength = Math.sqrt(effectiveBraceWidth * effectiveBraceWidth + effectiveBraceHeight * effectiveBraceHeight);
                const braceGeom = new THREE.BoxGeometry(braceLength, frameThickness, frameThickness);
                const brace = new THREE.Mesh(braceGeom, material);
                brace.position.set(0, itemData.height / 2, 0);
                brace.rotation.z = Math.atan2(effectiveBraceHeight, effectiveBraceWidth) * (effectiveBraceWidth > 0 ? 1 : -1);
                group.add(brace);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                group.position.y = 0.01;
                return group;
            }

            createChickenCoopMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                const wallHeight = itemData.height * 0.7;
                const roofPeakHeight = itemData.height;
                const peakRise = roofPeakHeight - wallHeight;
                const coopBodyGeom = new THREE.BoxGeometry(itemData.width, wallHeight, itemData.depth);
                const coopBodyMesh = new THREE.Mesh(coopBodyGeom, material);
                coopBodyMesh.position.y = wallHeight / 2;
                group.add(coopBodyMesh);
                const roofMaterial = new THREE.MeshStandardMaterial({ color: material.color.clone().multiplyScalar(0.7), roughness: 0.95 });
                const roof = this.createPitchedRoof(itemData.width, itemData.depth, peakRise, roofMaterial, 0.15, 0.05);
                roof.position.y = wallHeight;
                group.add(roof);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createPolytunnelMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({
                    ...itemData.materialProps,
                    side: THREE.DoubleSide
                });
                const width = itemData.width;
                const height = itemData.height;
                const depth = itemData.depth;
                const archShape = new THREE.Shape();
                const halfWidth = width / 2;
                archShape.moveTo(-halfWidth, 0);
                archShape.absarc(0, 0, halfWidth, Math.PI, 0, true);
                archShape.lineTo(halfWidth, 0);
                const extrudeSettings = { steps: 2, depth: depth, bevelEnabled: false, };
                const geometry = new THREE.ExtrudeGeometry(archShape, extrudeSettings);
                const scaleY = height / halfWidth;
                geometry.scale(1, scaleY, 1);
                const polytunnelMesh = new THREE.Mesh(geometry, material);
                polytunnelMesh.position.set(0, 0.01, -depth / 2);
                group.add(polytunnelMesh);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createComposterMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                const wallThickness = 0.05;
                const innerWidth = itemData.width - 2 * wallThickness;
                const innerDepth = itemData.depth - 2 * wallThickness;
                const fbWallGeom = new THREE.BoxGeometry(itemData.width, itemData.height, wallThickness);
                const frontWall = new THREE.Mesh(fbWallGeom, material);
                frontWall.position.set(0, itemData.height / 2, (itemData.depth - wallThickness) / 2);
                group.add(frontWall);
                const backWall = new THREE.Mesh(fbWallGeom.clone(), material);
                backWall.position.set(0, itemData.height / 2, -(itemData.depth - wallThickness) / 2);
                group.add(backWall);
                const lrWallGeom = new THREE.BoxGeometry(wallThickness, itemData.height, innerDepth);
                const leftWall = new THREE.Mesh(lrWallGeom, material);
                leftWall.position.set(-(innerWidth + wallThickness) / 2, itemData.height / 2, 0);
                group.add(leftWall);
                const rightWall = new THREE.Mesh(lrWallGeom.clone(), material);
                rightWall.position.set((innerWidth + wallThickness) / 2, itemData.height / 2, 0);
                group.add(rightWall);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }

            createEUPalletMesh(itemData) {
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial(itemData.materialProps);
                const plankThickness = 0.022;
                const blockHeight = 0.078;
                const totalHeight = 0.144;
                const topPlankGeom = new THREE.BoxGeometry(itemData.width, plankThickness, 0.145);
                const topPlankY = totalHeight - (plankThickness / 2);
                const topPlankSpacing = (itemData.depth - 0.145) / 2;
                [-topPlankSpacing, 0, topPlankSpacing].forEach(zPos => {
                    const plank = new THREE.Mesh(topPlankGeom, material);
                    plank.position.set(0, topPlankY, zPos);
                    group.add(plank);
                });
                const narrowTopPlankGeom = new THREE.BoxGeometry(itemData.width, plankThickness, 0.1);
                const narrowTopPlankSpacing = (itemData.depth - 0.1) / 2;
                [-narrowTopPlankSpacing, narrowTopPlankSpacing].forEach(zPos => {
                    const plank = new THREE.Mesh(narrowTopPlankGeom, material);
                    plank.position.set(0, topPlankY, zPos);
                    group.add(plank);
                });
                const blockY = plankThickness + (blockHeight / 2);
                const cornerBlockGeom = new THREE.BoxGeometry(0.145, blockHeight, 0.145);
                const centerBlockGeom = new THREE.BoxGeometry(0.145, blockHeight, 0.1);
                const blockXSpacing = (itemData.width - 0.145) / 2;
                const blockZSpacing = (itemData.depth - 0.145) / 2;
                [-blockXSpacing, 0, blockXSpacing].forEach(xPos => {
                    [-blockZSpacing, blockZSpacing].forEach(zPos => {
                        const block = new THREE.Mesh(cornerBlockGeom, material);
                        block.position.set(xPos, blockY, zPos);
                        group.add(block);
                    });
                     const centerBlock = new THREE.Mesh(centerBlockGeom, material);
                     centerBlock.position.set(xPos, blockY, 0);
                     group.add(centerBlock);
                });
                const bottomPlankY = plankThickness / 2;
                const bottomPlankXSpacing = (itemData.width - 0.145) / 2;
                [-bottomPlankXSpacing, bottomPlankXSpacing].forEach(xPos => {
                    const plank = new THREE.Mesh(new THREE.BoxGeometry(0.1, plankThickness, itemData.depth), material);
                    plank.position.set(xPos, bottomPlankY, 0);
                    group.add(plank);
                });
                const centerBottomPlank = new THREE.Mesh(new THREE.BoxGeometry(0.145, plankThickness, itemData.depth), material);
                centerBottomPlank.position.set(0, bottomPlankY, 0);
                group.add(centerBottomPlank);
                group.userData.dimensions = itemData;
                group.name = itemData.name;
                return group;
            }


            _createMeshFromDefinition(itemData) {
                if (itemData.isHollow) {
                    return this.createPlanterMeshes(
                        itemData.width, itemData.depth, itemData.height,
                        itemData.defaultWallThickness, itemData.defaultSoilHeight,
                        itemData.materialProps, { color: 0x6B4226, roughness: 0.9 }
                    );
                } else if (itemData.isScalable) {
                    return this.createPlantMesh(itemData);
                } else {
                    switch (itemData.name) {
                        case 'Shed': return this.createShedMesh(itemData);
                        case 'Greenhouse': return this.createGreenhouseMesh(itemData);
                        case 'Water Butt': return this.createWaterButtMesh(itemData);
                        case 'Fence Section': return this.createFenceSectionMesh(itemData);
                        case 'Gate': return this.createGateMesh(itemData);
                        case 'Chicken Coop': return this.createChickenCoopMesh(itemData);
                        case 'Polytunnel': return this.createPolytunnelMesh(itemData);
                        case 'Composter': return this.createComposterMesh(itemData);
                        case 'EU Pallet': return this.createEUPalletMesh(itemData);
                        default: return this.createBasicStructureMesh(itemData);
                    }
                }
            }

            _createAndPlaceObject(itemData, worldPosition, rotationY, parentObject = null) {
                const newObject = this._createMeshFromDefinition(itemData);
                newObject.userData.dimensions = { ...itemData };
                newObject.name = itemData.name;
                newObject.position.copy(worldPosition);
                newObject.rotation.y = rotationY;
                newObject.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                if (parentObject) {
                    parentObject.add(newObject);
                    if (!parentObject.userData.plants) parentObject.userData.plants = [];
                    parentObject.userData.plants.push(newObject);
                } else {
                    this.placedObjects.push(newObject);
                    this.scene.add(newObject);
                }
                if (this.showLabels) {
                    const label = this.createObjectLabelSprite(newObject);
                    if (label) {
                        this.allObjectLabels.add(label.sprite);
                        if (label.line) this.allObjectLabels.add(label.line);
                        this.labelSprites.set(newObject.uuid, label);
                    }
                }
                this.updatePlantSummaryPanel();
                return newObject;
            }

            _removeObjectAndCleanup(objectToRemove, isPlanterPlant = false) {
                if (!objectToRemove) return;
                objectToRemove.parent?.remove(objectToRemove);
                if (isPlanterPlant && this.activePlanter && this.activePlanter.userData.plants) {
                    const index = this.activePlanter.userData.plants.indexOf(objectToRemove);
                    if (index > -1) this.activePlanter.userData.plants.splice(index, 1);
                } else if (!isPlanterPlant) {
                    const index = this.placedObjects.indexOf(objectToRemove);
                    if (index > -1) this.placedObjects.splice(index, 1);
                }
                if (this.labelSprites.has(objectToRemove.uuid)) {
                    const { sprite, line } = this.labelSprites.get(objectToRemove.uuid);
                    this.allObjectLabels.remove(sprite);
                    disposeObject(sprite);
                    if (line) {
                        this.allObjectLabels.remove(line);
                        disposeObject(line);
                    }
                    this.labelSprites.delete(objectToRemove.uuid);
                }
                if (objectToRemove.userData.isPlanter && objectToRemove.userData.plants) {
                    [...objectToRemove.userData.plants].forEach(plant => this._removeObjectAndCleanup(plant, true));
                    objectToRemove.userData.plants = [];
                }
                disposeObject(objectToRemove);
                this.updatePlantSummaryPanel();
            }

            clearSceneObjects(fromUndo = false) {
                this.deselectObject();
                while (this.placedObjects.length > 0) {
                    this._removeObjectAndCleanup(this.placedObjects[0]);
                }
                if (!fromUndo) {
                    this.undoManager.clear();
                    this.infoPanel.show("Plot Cleared", "All objects have been removed.", {text: "OK"});
                }
                this.updatePlantSummaryPanel();
            }
            
            confirmAndClearAll() {
                this.infoPanel.show(
                    'Confirm Clear',
                    'Are you sure you want to remove all objects from the plot? This cannot be undone by reloading.',
                    {
                        text: 'Yes, Clear All',
                        onClick: () => this.clearSceneObjects()
                    }
                );
            }

            randomizeLayout() {
                this.clearSceneObjects();
                const plotWidth = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const plotLength = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const halfW = plotWidth / 2;
                const halfL = plotLength / 2;
                const itemCount = THREE.MathUtils.randInt(5, 12);
                let placedCount = 0;
                for (let i = 0; i < itemCount; i++) {
                    const itemDef = STRUCTURES[THREE.MathUtils.randInt(0, STRUCTURES.length - 1)];
                    const maxAttempts = 20;
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                        const rotationY = (Math.PI / 2) * THREE.MathUtils.randInt(0, 3);
                        const effectiveDims = this.getEffectiveDimensions(itemDef, rotationY);
                        const x = THREE.MathUtils.randFloat(-halfW + effectiveDims.width / 2, halfW - effectiveDims.width / 2);
                        const z = THREE.MathUtils.randFloat(-halfL + effectiveDims.depth / 2, halfL - effectiveDims.depth / 2);
                        const tempObject = this._createMeshFromDefinition(itemDef);
                        tempObject.position.set(x, 0, z);
                        tempObject.rotation.y = rotationY;
                        tempObject.updateMatrixWorld(true);
                        if (!this.isOverlapping(tempObject)) {
                            this._createAndPlaceObject(itemDef, tempObject.position, rotationY);
                            placedCount++;
                            disposeObject(tempObject);
                            break;
                        }
                        disposeObject(tempObject);
                    }
                }
                this.undoManager.saveState();
                this.infoPanel.show("Random Layout Generated", `Successfully placed ${placedCount} structures.`, { text: "OK" });
            }

            updateGeneralPlacementPreview(itemData) {
                // --- START: Robust Cleanup ---
                // This is critical to prevent "ghost" objects and ensure updates.
                if (this.placementPreview) {
                    this.scene.remove(this.placementPreview);
                    disposeObject(this.placementPreview);
                    this.placementPreview = null;
                }
                if (this.debugBoxHelper) {
                    this.scene.remove(this.debugBoxHelper);
                    disposeObject(this.debugBoxHelper);
                    this.debugBoxHelper = null;
                }
                if (this.debugBoxHelperUpdater) {
                    this.loop.updatables = this.loop.updatables.filter(u => u !== this.debugBoxHelperUpdater);
                    this.debugBoxHelperUpdater = null;
                }
                // --- END: Robust Cleanup ---

                const previewItemData = { ...itemData };
                // Create the new mesh using the provided itemData (which can have a dynamic width)
                this.placementPreview = this._createMeshFromDefinition(previewItemData);

                // Make it look like a preview
                this.placementPreview.traverse(child => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0.7;
                    }
                });
                
                this.placementPreview.userData.dimensions = previewItemData; // Store the data used to create it
                this.placementPreview.position.y = 0;
                this.placementPreview.rotation.y = this.placementRotation;
                this.placementPreview.visible = false; // Initially hidden until positioned
                this.scene.add(this.placementPreview);

                // Bounding box for valid/invalid placement coloring
                this.debugBoxHelper = new THREE.BoxHelper(this.placementPreview, 0xFFFF00); // Yellow color for preview
                this.debugBoxHelper.material.depthTest = false;
                this.debugBoxHelper.renderOrder = 1000;
                this.debugBoxHelper.visible = false;
                this.scene.add(this.debugBoxHelper);
                
                this.debugBoxHelperUpdater = { update: () => {
                    if (this.debugBoxHelper && this.placementPreview) {
                        this.placementPreview.updateMatrixWorld(true);
                        this.debugBoxHelper.update();
                    }
                }};
                this.loop.updatables.push(this.debugBoxHelperUpdater);
            }

            enterPlacementMode(item) {
                this.deselectObject();
                this.exitPlacementMode();
                this.exitPlantInPlanterSelectionMode();
                this.mode = 'PLACEMENT';
                this.placementRotation = 0;
                this.controls.enabled = false;
                this.temporaryPlacementConfig = { ...item };
                if (item.isHollow) {
                    this.temporaryPlacementConfig.wallThickness = item.defaultWallThickness;
                    this.temporaryPlacementConfig.soilHeight = item.defaultSoilHeight;
                    this.temporaryPlacementConfig.soilRows = item.soilRows || 1;
                    this.temporaryPlacementConfig.soilCols = item.soilCols || 1;
                } else if (item.isScalable) {
                    this.temporaryPlacementConfig.growth = item.defaultGrowth || 1.0;
                }
                
                // Special handling for fence/gate single-click-drag placement start
                if (item.name === 'Fence Section' || item.name === 'Gate') {
                    this.infoPanel.show('Start Fence/Gate', 'Click on the plot to set the starting point.');
                } else {
                    this.showPlacementSettingsPanel(item, this.temporaryPlacementConfig);
                    this.updateGeneralPlacementPreview(this.temporaryPlacementConfig);
                }
            }

            exitPlacementMode() {
                this.mode = 'IDLE';
                this.fenceStartPoint = null; // Clear the start point

                if (this.placementPreview) {
                    this.scene.remove(this.placementPreview);
                    disposeObject(this.placementPreview); // Make sure it and its materials/geometries are disposed
                    this.placementPreview = null;
                }
                if (this.debugBoxHelper) {
                    this.scene.remove(this.debugBoxHelper);
                    disposeObject(this.debugBoxHelper);
                    this.debugBoxHelper = null;
                }
                if (this.debugBoxHelperUpdater) {
                    this.loop.updatables = this.loop.updatables.filter(u => u !== this.debugBoxHelperUpdater);
                    this.debugBoxHelperUpdater = null;
                }
                
                this._hideSnapMarker();
                
                this._initRightToolPanel('', true);
                this.setViewLock(this.controlsPanel.config.viewLocked);
                this.sidebar.deselect();
                this.infoPanel.hide();
            }



            // --- NEW: SNAPPING TARGET SYSTEM ---
            _getSnapTargets() {
                const targets = [];
                
                // Add plot corners
                const plotW = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const plotL = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const halfW = plotW / 2;
                const halfL = plotL / 2;
                
                targets.push(new THREE.Vector3(-halfW, 0, -halfL)); // Bottom-left
                targets.push(new THREE.Vector3(halfW, 0, -halfL));  // Bottom-right
                targets.push(new THREE.Vector3(halfW, 0, halfL));   // Top-right
                targets.push(new THREE.Vector3(-halfW, 0, halfL));  // Top-left
                
                // Add fence/gate endpoints
                for (const obj of this.placedObjects) {
                    if (obj.userData.dimensions?.snappable) {
                        const snapPoints = this._calculateEnhancedSnapPoints(obj);
                        for (const snap of snapPoints) {
                            targets.push(snap.position.clone());
                        }
                    }
                }
                
                return targets;
            }

            _findBestSnapPoint(cursorPoint) {
                const targets = this._getSnapTargets();
                const snapThreshold = 0.75; // meters
                let bestTarget = null;
                let bestDistance = Infinity;
                
                for (const target of targets) {
                    const distance = cursorPoint.distanceTo(target);
                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestTarget = target;
                    }
                }
                
                // Return snapped point if within threshold, otherwise return original
                if (bestTarget && bestDistance < snapThreshold) {
                    // Show snap marker
                    this._showSnapMarker(bestTarget);
                    return bestTarget.clone();
                } else {
                    // Hide snap marker
                    this._hideSnapMarker();
                    return cursorPoint.clone();
                }
            }

            _showSnapMarker(position) {
                if (!this.snapMarker) {
                    const geometry = new THREE.SphereGeometry(0.08, 8, 6);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x00ff00, 
                        transparent: true, 
                        opacity: 0.8 
                    });
                    this.snapMarker = new THREE.Mesh(geometry, material);
                    this.snapMarker.renderOrder = 1000;
                    this.scene.add(this.snapMarker);
                }
                
                this.snapMarker.position.copy(position);
                this.snapMarker.position.y = 0.1; // Slightly above ground
                this.snapMarker.visible = true;
            }

            _hideSnapMarker() {
                if (this.snapMarker) {
                    this.snapMarker.visible = false;
                }
            }

            placeObject(position, customData = null, customRotation = null) {
                const itemData = customData || this.temporaryPlacementConfig;
                const rotation = customRotation !== null ? customRotation : this.placementRotation;
                this._createAndPlaceObject(itemData, position, rotation);
                this.exitPlacementMode();
                this.undoManager.saveState(); // Save state after placing
            }

            selectObject(object) {
                if (this.selectedObject === object || this.mode.startsWith('MOVE') || this.mode.startsWith('PLANT')) return;
                this.deselectObject();
                this.selectedObject = object;
                this.selectionBox = new THREE.BoxHelper(object, 0xffffff);
                this.selectionBox.material.depthTest = false;
                this.selectionBox.renderOrder = 999; 
                this.scene.add(this.selectionBox);
                this.selectionBoxUpdater = { update: () => this.selectionBox.update() };
                this.loop.updatables.push(this.selectionBoxUpdater);
                this._updateDimensionLabels(); // <-- ADD THIS LINE
                if (object.userData.dimensions?.resizable) {
                    this.resizeHandles.attach(object);
                }
                this.infoPanel.show(`Selected: ${object.name}`, 'Use the editor panel to modify or delete this object.', { text: 'Delete', onClick: () => this.removeSelectedObject() });
                this.createObjectEditor();
                if (object.userData.isPlanter) this.showPlanterGrid(object);
            }

            selectPlantInPlanter(plantObject, planterObject) {
                if (this.selectedPlantInPlanter === plantObject) return;
                this.deselectObject();
                this.selectedObject = planterObject;
                this.selectedPlantInPlanter = plantObject;
                this.plantSelectionBox = new THREE.BoxHelper(plantObject, 0xffffff);
                this.plantSelectionBox.material.depthTest = false;
                this.plantSelectionBox.renderOrder = 999; 
                this.scene.add(this.plantSelectionBox); 
                this.plantSelectionBoxUpdater = { update: () => this.plantSelectionBox.update() };
                this.loop.updatables.push(this.plantSelectionBoxUpdater);
                this.infoPanel.show(`Selected: ${plantObject.name}`, 'Use the editor panel to modify or delete this plant.', { text: 'Delete', onClick: () => this.removeSelectedPlantInPlanter() });
                this.createPlantEditor();
                if (planterObject.userData.isPlanter) this.showPlanterGrid(planterObject);
            }

            deselectObject() {
                this.deselectPlantInPlanter();
                if (!this.selectedObject) return;
                this.resizeHandles.detach();
                if (this.selectionBoxUpdater) {
                    this.loop.updatables.splice(this.loop.updatables.indexOf(this.selectionBoxUpdater), 1);
                    this.selectionBoxUpdater = null;
                }
                if(this.selectionBox) { this.scene.remove(this.selectionBox); disposeObject(this.selectionBox); this.selectionBox = null; }
                this.selectedObject = null;
                this.dimensionLabelGroup.visible = false; // <-- ADD THIS LINE
                this.infoPanel.hide();
                this.hidePlanterGrid();
                this._initRightToolPanel('', true);
            }

            deselectPlantInPlanter() {
                if (!this.selectedPlantInPlanter) return;
                if (this.plantSelectionBoxUpdater) {
                    this.loop.updatables.splice(this.loop.updatables.indexOf(this.plantSelectionBoxUpdater), 1);
                    this.plantSelectionBoxUpdater = null;
                }
                if (this.plantSelectionBox) {
                    this.plantSelectionBox.parent?.remove(this.plantSelectionBox);
                    disposeObject(this.plantSelectionBox);
                    this.plantSelectionBox = null;
                }
                this.selectedPlantInPlanter = null;
            }

            removeSelectedObject() {
                if (!this.selectedObject) return;
                this.resizeHandles.detach();
                this.infoPanel.show("Object Removed", "The object has been removed.", {text: "OK"});
                this._removeObjectAndCleanup(this.selectedObject);
                this.deselectObject();
                this.undoManager.saveState(); // Save state after removal
            }

            removeSelectedPlantInPlanter() {
                if (!this.selectedPlantInPlanter || !this.selectedObject) return;
                this._savePlanterStateToHistory();
                this.infoPanel.show("Plant Removed", "The plant has been removed.", {text: "OK"});
                const planter = this.selectedObject;
                this._removeObjectAndCleanup(this.selectedPlantInPlanter, true);
                this.selectObject(planter);
                this.undoManager.saveState(); // Save state after removal
            }

            enterMoveMode() {
                if (!this.selectedObject) return;
                this.objectToMove = this.selectedObject;
                this.originalPosition = this.selectedObject.position.clone();
                this.placementRotation = this.selectedObject.rotation.y;
                this.mode = 'MOVE';
                this.deselectObject();
                this.updateGeneralPlacementPreview(this.objectToMove.userData.dimensions);
                this.placementPreview.position.copy(this.originalPosition);
                this.placementPreview.visible = true;
                if (this.debugBoxHelper) this.debugBoxHelper.visible = true;
                this.objectToMove.visible = false;
                this.controls.enabled = false;
                this.infoPanel.show('Moving Object', `Click to place. R to rotate. Esc to cancel.`, null);
            }

            exitMoveMode(finalize) {
                const movedObject = this.objectToMove;
                if (!movedObject) return;
                if (finalize && this.isPlacementValid) {
                    movedObject.position.copy(this.placementPreview.position);
                    movedObject.rotation.copy(this.placementPreview.rotation);
                    this.infoPanel.show("Object Moved", "Move successful.", {text: "OK"});
                    this.undoManager.saveState(); // Save state on successful move
                } else {
                    movedObject.position.copy(this.originalPosition);
                    if (finalize && !this.isPlacementValid) {
                        this.infoPanel.show("Invalid Move", "Cannot move here. Position restored.", {text: "OK"});
                    } else {
                        this.infoPanel.show("Move Cancelled", "Position restored.", {text: "OK"});
                    }
                }
                movedObject.visible = true;
                if (this.placementPreview) {
                    this.scene.remove(this.placementPreview);
                    disposeObject(this.placementPreview);
                    this.placementPreview = null;
                }
                if (this.debugBoxHelper) {
                    this.scene.remove(this.debugBoxHelper);
                    disposeObject(this.debugBoxHelper);
                    this.debugBoxHelper = null;
                }
                if (this.debugBoxHelperUpdater) {
                    this.loop.updatables = this.loop.updatables.filter(u => u !== this.debugBoxHelperUpdater);
                    this.debugBoxHelperUpdater = null;
                }
                this.mode = 'IDLE';
                this.objectToMove = null;
                this.setViewLock(this.controlsPanel.config.viewLocked);
                this.selectObject(movedObject);
            }

            enterMovePlantInPlanterMode() {
                if (!this.selectedPlantInPlanter || !this.selectedObject) return;
                this.mode = 'MOVE_PLANT_IN_PLANTER';
                this.activePlanter = this.selectedObject;
                this.objectToMove = this.selectedPlantInPlanter;
                this.originalPosition = this.objectToMove.position.clone();
                this.placementRotation = this.objectToMove.rotation.y;
                this.plantToPlaceInPlanterConfig = { ...this.objectToMove.userData.dimensions };
                this.updatePlantInPlanterPreview();
                if (this.plantPlacementPreview) {
                    this.plantPlacementPreview.position.copy(this.originalPosition);
                    this.activePlanter.add(this.plantPlacementPreview);
                }
                this.objectToMove.visible = false;
                this.deselectPlantInPlanter();
                this.controls.enabled = false;
                this.infoPanel.show('Moving Plant', 'Click to place. Esc to cancel.', null);
                this._initRightToolPanel(`Move ${this.plantToPlaceInPlanterConfig.name}`);
            }

            exitMovePlantInPlanterMode(finalize) {
                const movedPlant = this.objectToMove;
                if (!movedPlant || !this.activePlanter) return;
                if (finalize && this.isPlacementValid) {
                    movedPlant.position.copy(this.plantPlacementPreview.position);
                    movedPlant.rotation.copy(this.plantPlacementPreview.rotation);
                    this.infoPanel.show("Plant Moved", "Move successful.", {text: "OK"});
                    this.undoManager.saveState(); // Save state on successful move
                } else {
                    movedPlant.position.copy(this.originalPosition);
                    if (finalize && !this.isPlacementValid) {
                        this.infoPanel.show("Invalid Move", "Cannot move plant here. Position restored.", {text: "OK"});
                    } else {
                        this.infoPanel.show("Move Cancelled", "Position restored.", {text: "OK"});
                    }
                }
                movedPlant.visible = true;
                if (this.plantPlacementPreview) {
                    this.plantPlacementPreview.parent?.remove(this.plantPlacementPreview);
                    disposeObject(this.plantPlacementPreview);
                    this.plantPlacementPreview = null;
                }
                this.mode = 'IDLE';
                this.objectToMove = null;
                const lastPlanter = this.activePlanter;
                this.activePlanter = null;
                this.setViewLock(this.controlsPanel.config.viewLocked);
                this.selectPlantInPlanter(movedPlant, lastPlanter);
            }

            _initRightToolPanel(title, forceHidden = false) {
                if (this.activeToolPane) {
                    this.activeToolPane.dispose();
                    this.activeToolPane = null;
                }

                if (title && !forceHidden) {
                    this.rightToolPanelContainer.classList.remove('hidden');
                    this.activeToolPane = new Tweakpane.Pane({ title: title, container: this.rightToolPanelContainer });
                } else {
                    this.rightToolPanelContainer.classList.add('hidden');
                }
                return this.activeToolPane;
            }

            createObjectEditor() {
                const pane = this._initRightToolPanel(`Edit ${this.selectedObject.name}`);
                if (!pane) return;
                pane.addButton({ title: 'Move Object' }).on('click', () => this.enterMoveMode());
                pane.addButton({ title: 'Rotate Object' }).on('click', () => {
                    if (this.selectedObject) {
                        this.selectedObject.rotation.y += Math.PI / 2;
                        if (this.selectionBox) this.selectionBox.update();
                        this._updateDimensionLabels();
                        this.undoManager.saveState(); // Save state on rotation
                    }
                });
                pane.addButton({ title: 'Delete Object' }).on('click', () => this.removeSelectedObject());
                if (this.selectedObject?.userData.isPlanter) {
                    const gridFolder = pane.addFolder({ title: 'Soil Grid', expanded: true });
                    gridFolder.addInput(this.selectedObject.userData.dimensions, 'soilRows', { label: 'Rows', min: 1, max: 10, step: 1 }).on('change', () => this.updatePlanterGrid(this.selectedObject));
                    gridFolder.addInput(this.selectedObject.userData.dimensions, 'soilCols', { label: 'Columns', min: 1, max: 10, step: 1 }).on('change', () => this.updatePlanterGrid(this.selectedObject));
                    gridFolder.addButton({ title: 'Add Plant' }).on('click', () => this.enterPlantInPlanterSelectionMode(this.selectedObject));
                }
            }

            createPlantEditor() {
                const plant = this.selectedPlantInPlanter;
                const pane = this._initRightToolPanel(`Edit ${plant.name}`);
                if (!pane) return;

                pane.addButton({ title: 'Move Plant' }).on('click', () => this.enterMovePlantInPlanterMode());
                pane.addButton({ title: 'Rotate Plant' }).on('click', () => { plant.rotation.y += Math.PI / 2; if (this.plantSelectionBox) this.plantSelectionBox.update(); this.undoManager.saveState(); });
                if (plant.userData.dimensions.isScalable) {
                    const growthInput = pane.addInput(plant.userData.dimensions, 'growth', { min: 0.1, max: 1.0, step: 0.01 });
                    growthInput.on('change', (ev) => this.updateSelectedPlantGrowth(ev.value));
                    // Save state on release, not on every change event
                    growthInput.element.addEventListener('mouseup', () => this.undoManager.saveState(), true);
                }
                pane.addButton({ title: 'Delete Plant' }).on('click', () => this.removeSelectedPlantInPlanter());
            }

            updateSelectedPlantGrowth(newGrowth) {
                if (!this.selectedPlantInPlanter || !this.selectedObject) return;
                const oldPlant = this.selectedPlantInPlanter;
                const planter = this.selectedObject;
                this._savePlanterStateToHistory();
                const plantDef = {
                    ...oldPlant.userData.dimensions,
                    growth: newGrowth,
                    originalWidth: oldPlant.userData.dimensions.originalWidth,
                    originalDepth: oldPlant.userData.dimensions.originalDepth,
                    originalHeight: oldPlant.userData.dimensions.originalHeight
                };
                const newPlant = this._createAndPlaceObject(plantDef, oldPlant.position, oldPlant.rotation.y, planter);
                this._removeObjectAndCleanup(oldPlant, true);
                newPlant.updateMatrixWorld(true);
                planter.updateMatrixWorld(true);
                this.selectedPlantInPlanter = newPlant;
                if (this.plantSelectionBoxUpdater) {
                    this.loop.updatables.splice(this.loop.updatables.indexOf(this.plantSelectionBoxUpdater), 1);
                    this.plantSelectionBoxUpdater = null;
                }
                if (this.plantSelectionBox) {
                    this.plantSelectionBox.parent?.remove(this.plantSelectionBox);
                    disposeObject(this.plantSelectionBox);
                    this.plantSelectionBox = null;
                }
                this.selectPlantInPlanter(newPlant, planter);
                this.updatePlantSummaryPanel();
            }

            showPlacementSettingsPanel(itemDef, configProxy) {
                const pane = this._initRightToolPanel(`Place ${itemDef.name}`);
                if (!pane) return;
                
                if (itemDef.isScalable && configProxy.originalWidth === undefined) {
                    configProxy.originalWidth = configProxy.width;
                    configProxy.originalDepth = configProxy.depth;
                    configProxy.originalHeight = configProxy.height;
                }
                const onUpdate = () => { this.updateGeneralPlacementPreview(configProxy); };

                if (itemDef.resizable) {
                    const dimsFolder = pane.addFolder({title: 'Dimensions', expanded: true});
                    dimsFolder.addInput(configProxy, 'width', { label: itemDef.isScalable ? 'Diameter' : 'Width', step: 0.1, min: 0.1 }).on('change', onUpdate);
                    if (!itemDef.isScalable) dimsFolder.addInput(configProxy, 'depth', { label: 'Depth', step: 0.1, min: 0.1 }).on('change', onUpdate);
                    dimsFolder.addInput(configProxy, 'height', { label: 'Height', step: 0.1, min: 0.1 }).on('change', onUpdate);
                }

                if (itemDef.isHollow) {
                    pane.addInput(configProxy, 'wallThickness', { label: 'Wall Thick', step: 0.01, min: 0.01 }).on('change', onUpdate);
                    pane.addInput(configProxy, 'soilHeight', { label: 'Soil Height', step: 0.01, min: 0 }).on('change', onUpdate);
                    pane.addInput(configProxy, 'soilRows', { label: 'Rows', min: 1, max: 10, step: 1 });
                    pane.addInput(configProxy, 'soilCols', { label: 'Columns', min: 1, max: 10, step: 1 });
                } else if (itemDef.isScalable) {
                    pane.addInput(configProxy, 'growth', { label: 'Growth', min: 0.1, max: 1.0, step: 0.01 }).on('change', onUpdate);
                }
            }

            updatePlantInPlanterPreview() {
                if (!this.plantToPlaceInPlanterConfig || !this.activePlanter) return;
                if (this.plantPlacementPreview) {
                    this.plantPlacementPreview.parent?.remove(this.plantPlacementPreview);
                    disposeObject(this.plantPlacementPreview);
                }
                this.plantPlacementPreview = this._createMeshFromDefinition(this.plantToPlaceInPlanterConfig);
                this.plantPlacementPreview.traverse(child => { if(child.isMesh) { child.material = child.material.clone(); child.material.transparent=true; child.material.opacity = 0.7; } });
                this.plantPlacementPreview.rotation.y = this.placementRotation;
                this.plantPlacementPreview.visible = false;
                this.activePlanter.add(this.plantPlacementPreview);
                this.onMouseMove();
            }

            enterPlantInPlanterSelectionMode(planter) {
                this.deselectObject();
                this.mode = 'PLANT_IN_PLANTER_SELECT_PLANT';
                this.activePlanter = planter;
                this.controls.enabled = false;
                this.showPlanterGrid(planter);
                this.showPlantSelectionPanel();
                this.infoPanel.show(`Add Plant to ${planter.name}`, 'Select a plant from the panel.', null);
            }

            activatePlantInPlanterPlacement(plantDef) {
                this.activePlanterHistory = [];
                this._savePlanterStateToHistory();
                const initialPlantDef = {
                    ...plantDef,
                    growth: plantDef.defaultGrowth || 1.0,
                    originalWidth: plantDef.width,
                    originalDepth: plantDef.depth,
                    originalHeight: plantDef.height
                };
                this.plantToPlaceInPlanterConfig = initialPlantDef;
                const pane = this._initRightToolPanel(`Place ${plantDef.name}`);
                if (!pane) return;
                this.showPlantGrowthSliderForPlanterPlacement(pane);
                this.addPlanterActionButtons(pane);
                this.addPopulateOptions(pane);
                this.updatePlantInPlanterPreview();
                this.mode = 'PLANT_IN_PLANTER_PLACEMENT';
                this.infoPanel.show(`Adding ${plantDef.name}`, 'Click soil to place. Esc to cancel. R to rotate.', null);
            }

            addPlanterActionButtons(pane) {
                const actionsFolder = pane.addFolder({ title: 'Planter Tools', expanded: true });
                actionsFolder.addButton({ title: '↩️ Undo Last Action' }).on('click', () => this.undoLastPlanterOperation());
                actionsFolder.addButton({ title: '🗑️ Remove All Plants' }).on('click', () => this.removeAllPlantsInPlanter());
            }

            addPopulateOptions(pane) {
                const { soilRows, soilCols } = this.activePlanter.userData.dimensions;
                const gridFolder = pane.addFolder({ title: 'Populate Grid', expanded: true });
                gridFolder.addButton({ title: 'Cells: All Centers' }).on('click', () => this._populateGrid(0, soilRows, 0, soilCols, 'center'));
                gridFolder.addButton({ title: 'Cells: Inner Centers' }).on('click', () => this._populateGrid(1, soilRows - 1, 1, soilCols - 1, 'center'));
                gridFolder.addButton({ title: 'Grid: All Intersections' }).on('click', () => this._populateGrid(0, soilRows, 0, soilCols, 'intersection'));
                gridFolder.addButton({ title: 'Grid: Inner Intersections' }).on('click', () => this._populateGrid(1, soilRows - 1, 1, soilCols - 1, 'intersection'));
                this.randomPopulateConfig = this.randomPopulateConfig || { count: 5 };
                const randomFolder = pane.addFolder({ title: 'Populate Randomly' });
                randomFolder.addInput(this.randomPopulateConfig, 'count', { min: 1, max: 50, step: 1, label: 'Count' });
                randomFolder.addButton({ title: 'Place Randomly' }).on('click', () => this._populateRandom(this.randomPopulateConfig.count));
            }

            exitPlantInPlanterSelectionMode() {
                this.mode = 'IDLE';
                if (this.plantPlacementPreview) {
                    this.plantPlacementPreview.parent?.remove(this.plantPlacementPreview);
                    disposeObject(this.plantPlacementPreview);
                    this.plantPlacementPreview = null;
                }
                this._initRightToolPanel('', true);
                const lastPlanter = this.activePlanter;
                this.activePlanter = null; 
                this.activePlanterHistory = [];
                this.setViewLock(this.controlsPanel.config.viewLocked);
                this.infoPanel.hide();
                if (lastPlanter && this.selectedObject === lastPlanter) {
                     this.selectObject(lastPlanter);
                } else {
                    this.deselectObject();
                }
            }

            showPlantSelectionPanel() {
                const pane = this._initRightToolPanel('Select Plant');
                if (!pane) return;
                pane.expanded = false; 
                for (const category in PLANTS) {
                    const folder = pane.addFolder({ title: category.charAt(0).toUpperCase() + category.slice(1) });
                    PLANTS[category].forEach(p => folder.addButton({ title: p.name }).on('click', () => this.activatePlantInPlanterPlacement(p)));
                }
            }

            showPlantGrowthSliderForPlanterPlacement(pane) {
                if (this.plantToPlaceInPlanterConfig?.isScalable) {
                    pane.addInput(this.plantToPlaceInPlanterConfig, 'growth', { label: 'Growth', min: 0.1, max: 1.0, step: 0.01 }).on('change', () => this.updatePlantInPlanterPreview());
                }
            }

            placePlantInPlanter(plantDef, localPosition, rotationY) {
                if (!this.activePlanter || !plantDef) return;
                this._savePlanterStateToHistory();
                this._createAndPlaceObject(plantDef, localPosition, rotationY, this.activePlanter);
                this.updatePlantSummaryPanel();
                this.undoManager.saveState();
            }

            _savePlanterStateToHistory() {
                if (!this.activePlanter) return;
                const currentState = this.activePlanter.userData.plants?.map(plant => ({
                    name: plant.name,
                    localPos: plant.position.toArray(),
                    rotY: plant.rotation.y,
                    dims: plant.userData.dimensions
                })) || [];
                this.activePlanterHistory.push(currentState);
                if (this.activePlanterHistory.length > this.MAX_PLANTER_HISTORY) {
                    this.activePlanterHistory.shift();
                }
            }

            _clearPlanterPlants(planter) {
                if (!planter) return;
                [...(planter.userData.plants || [])].forEach(plant => this._removeObjectAndCleanup(plant, true));
                planter.userData.plants = []; 
            }

            _rebuildPlanterPlantsFromData(planter, plantDataArray) {
                this._clearPlanterPlants(planter);
                if (!planter.userData.plants) planter.userData.plants = [];
                plantDataArray.forEach(pItem => {
                    const pDef = Object.values(PLANTS).flat().find(p => p.name === pItem.name);
                    if (!pDef) { console.warn(`Definition not found for plant in history: ${pItem.name}`); return; }
                    const plantDimensions = { ...pDef, ...pItem.dims,
                        originalWidth: pItem.dims.originalWidth ?? pDef.width,
                        originalDepth: pItem.dims.originalDepth ?? pDef.depth,
                        originalHeight: pItem.dims.originalHeight ?? pDef.height,
                    };
                    this._createAndPlaceObject(plantDimensions, new THREE.Vector3().fromArray(pItem.localPos), pItem.rotY, planter);
                });
            }

            removeAllPlantsInPlanter() {
                if (!this.activePlanter) return;
                this._savePlanterStateToHistory();
                this._clearPlanterPlants(this.activePlanter);
                this.infoPanel.show("Plants Removed", `All plants cleared from ${this.activePlanter.name}. Press Esc to exit or Undo to restore.`, null);
                this.updatePlantSummaryPanel();
                this.undoManager.saveState();
            }

            undoLastPlanterOperation() {
                if (!this.activePlanter || this.activePlanterHistory.length <= 1) {
                    this.infoPanel.show("Undo Failed", "Nothing more to undo for this planter.", {text: "OK"});
                    return;
                }
                this.activePlanterHistory.pop();
                const previousState = this.activePlanterHistory[this.activePlanterHistory.length - 1];
                this._rebuildPlanterPlantsFromData(this.activePlanter, previousState);
                this.infoPanel.show("Undo Successful", `Reverted ${this.activePlanter.name} to previous state.`, null);
                this.undoManager.saveState();
            }

            _populateGrid(r_start, r_end, c_start, c_end, positionType) {
                if (!this.activePlanter || !this.plantToPlaceInPlanterConfig) return;
                const { dimensions: outer, innerDimensions: inner } = this.activePlanter.userData;
                if (!inner) return;
                this._savePlanterStateToHistory();
                const plantsToAdd = [];
                const colSize = inner.width / outer.soilCols;
                const rowSize = inner.depth / outer.soilRows;
                const halfW = inner.width / 2;
                const halfD = inner.depth / 2;
                let count = 0;
                const actual_r_end = (positionType === 'center') ? r_end : (r_end + 1);
                const actual_c_end = (positionType === 'center') ? c_end : (c_end + 1);
                const soilTopY = this.activePlanter.children.find(c => c.name === 'planterSoil')?.position.y +
                                 this.activePlanter.children.find(c => c.name === 'planterSoil')?.geometry.parameters.height / 2;
                for (let r = r_start; r < actual_r_end; r++) {
                    for (let c = c_start; c < actual_c_end; c++) {
                        let localX, localZ;
                        if (positionType === 'center') {
                            localX = -halfW + c * colSize + colSize / 2;
                            localZ = -halfD + r * rowSize + rowSize / 2;
                        } else { localX = -halfW + c * colSize; localZ = -halfD + r * rowSize; }
                        const pos = this.getPlanterLocalSoilPosition(new THREE.Vector3(localX, soilTopY, localZ), this.activePlanter, this.plantToPlaceInPlanterConfig, this.placementRotation);
                        const tempPlant = this._createMeshFromDefinition(this.plantToPlaceInPlanterConfig);
                        tempPlant.position.copy(pos);
                        tempPlant.rotation.y = this.placementRotation;
                        this.activePlanter.add(tempPlant);
                        this.activePlanter.updateMatrixWorld(true);
                        const isColliding = this.isOverlappingInPlanter(tempPlant, this.activePlanter, null);
                        this.activePlanter.remove(tempPlant); disposeObject(tempPlant);
                        if (!isColliding) {
                            plantsToAdd.push({ name: this.plantToPlaceInPlanterConfig.name, localPos: pos.toArray(), rotY: this.placementRotation, dims: { ...this.plantToPlaceInPlanterConfig } });
                            count++;
                        }
                    }
                }
                this._rebuildPlanterPlantsFromData(this.activePlanter, plantsToAdd);
                if (this.plantPlacementPreview) { this.plantPlacementPreview.parent?.remove(this.plantPlacementPreview); disposeObject(this.plantPlacementPreview); this.plantPlacementPreview = null; }
                this.infoPanel.show("Grid Populated", `Placed ${count} plants.`, null);
                this.undoManager.saveState();
            }

            _populateRandom(count) {
                if (!this.activePlanter || !this.plantToPlaceInPlanterConfig) return;
                this._savePlanterStateToHistory();
                const { innerDimensions: inner } = this.activePlanter.userData;
                if (!inner) return;
                const plantsToAdd = [];
                const plantConfig = this.plantToPlaceInPlanterConfig;
                const plantDims = this.getEffectiveDimensions(plantConfig, this.placementRotation);
                const maxAttempts = count * 10;
                let attempts = 0, placedCount = 0;
                const soilTopY = this.activePlanter.children.find(c => c.name === 'planterSoil')?.position.y + this.activePlanter.children.find(c => c.name === 'planterSoil')?.geometry.parameters.height / 2;
                while (placedCount < count && attempts < maxAttempts) {
                    attempts++;
                    const minX = -inner.width / 2 + plantDims.width / 2, maxX = inner.width / 2 - plantDims.width / 2;
                    const minZ = -inner.depth / 2 + plantDims.depth / 2, maxZ = inner.depth / 2 - plantDims.depth / 2;
                    if (minX > maxX || minZ > maxZ) { this.infoPanel.show("Placement Error", "Plant is too large.", {text: "OK"}); break; }
                    const localX = THREE.MathUtils.randFloat(minX, maxX);
                    const localZ = THREE.MathUtils.randFloat(minZ, maxZ);
                    const localPos = new THREE.Vector3(localX, soilTopY, localZ);
                    const tempPlant = this._createMeshFromDefinition(plantConfig);
                    tempPlant.position.copy(localPos);
                    tempPlant.rotation.y = this.placementRotation;
                    this.activePlanter.add(tempPlant); this.activePlanter.updateMatrixWorld(true);
                    const isColliding = this.isOverlappingInPlanter(tempPlant, this.activePlanter, null);
                    this.activePlanter.remove(tempPlant); disposeObject(tempPlant);
                    if (!isColliding) {
                        plantsToAdd.push({ name: plantConfig.name, localPos: localPos.toArray(), rotY: this.placementRotation, dims: { ...plantConfig } });
                        placedCount++;
                    }
                }
                this._rebuildPlanterPlantsFromData(this.activePlanter, plantsToAdd);
                if (this.plantPlacementPreview) { this.plantPlacementPreview.parent?.remove(this.plantPlacementPreview); disposeObject(this.plantPlacementPreview); this.plantPlacementPreview = null; }
                this.infoPanel.show("Random Placement Complete", `Placed ${placedCount} plants.`, null);
                this.undoManager.saveState();
            }


            showPlanterGrid(planter) {
                this.hidePlanterGrid();
                const soil = planter.children.find(c => c.name === 'planterSoil');
                if (!soil) return;
                const { innerDimensions: inner, dimensions: outer } = planter.userData;
                const points = [], halfW = inner.width/2, halfD = inner.depth/2;
                for (let i = 0; i <= outer.soilCols; i++) {
                    const x = -halfW + i * (inner.width / outer.soilCols);
                    points.push(new THREE.Vector3(x,0,-halfD), new THREE.Vector3(x,0,halfD));
                }
                for (let i = 0; i <= outer.soilRows; i++) {
                    const z = -halfD + i * (inner.depth / outer.soilRows);
                    points.push(new THREE.Vector3(-halfW,0,z), new THREE.Vector3(halfW,0,z));
                }
                const geom = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.7 });
                this.planterGridHelper = new THREE.LineSegments(geom, mat);
                this.planterGridHelper.position.y = soil.position.y + soil.geometry.parameters.height / 2 + 0.01;
                planter.add(this.planterGridHelper);
            }
            updatePlanterGrid(planter) { this.hidePlanterGrid(); this.showPlanterGrid(planter); this.undoManager.saveState(); }
            hidePlanterGrid() { if (this.planterGridHelper) { this.planterGridHelper.parent?.remove(this.planterGridHelper); disposeObject(this.planterGridHelper); this.planterGridHelper = null; } }

            updateMouse(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            }

            _handleMouseMovePlacement() {
                if (!this.placementPreview) return;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.plot.ground);
                if (intersects.length > 0) {
                    const itemData = this.mode === 'PLACEMENT' ? this.temporaryPlacementConfig : this.objectToMove.userData.dimensions;
                    const snapResult = this.calculateSnapping(intersects[0].point, itemData, this.placementRotation);
                    this.placementPreview.position.copy(snapResult.position);
                    this.placementPreview.position.y = 0; // Prevent clipping into the ground
                    this.placementPreview.rotation.y = snapResult.rotation;
                    // Update the ongoing placement rotation in case the edge snap changed it
                    this.placementRotation = snapResult.rotation;
                    this.placementPreview.visible = true;
                    if (this.debugBoxHelper) this.debugBoxHelper.visible = true; 
                    this.placementPreview.updateMatrixWorld(true);
                    this.isPlacementValid = !this.isOverlapping(this.placementPreview);
                    const color = this.isPlacementValid ? this.validPlacementColor : this.invalidPlacementColor;
                    this.placementPreview.traverse(c => { if (c.isMesh && c.name !== 'planterSoil') c.material.color.set(color); });
                } else {
                    this.placementPreview.visible = false;
                    if (this.debugBoxHelper) this.debugBoxHelper.visible = false; 
                }
            }

            _handleMouseMovePlantInPlanter() {
                if (!this.plantPlacementPreview || !this.activePlanter) return;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const soil = this.activePlanter.children.find(c => c.name === 'planterSoil');
                if (!soil) { this.plantPlacementPreview.visible = false; return; }
                const intersects = this.raycaster.intersectObject(soil);
                if (intersects.length > 0) {
                    const localPoint = this.activePlanter.worldToLocal(intersects[0].point.clone());
                    const snappedPos = this.calculatePlanterGridSnapping(localPoint, this.activePlanter, this.plantToPlaceInPlanterConfig, this.placementRotation);
                    this.plantPlacementPreview.position.copy(snappedPos);
                    this.plantPlacementPreview.rotation.y = this.placementRotation;
                    this.plantPlacementPreview.visible = true;
                    this.plantPlacementPreview.updateMatrixWorld(true);
                    const ignore = this.mode === 'MOVE_PLANT_IN_PLANTER' ? this.objectToMove : null;
                    this.isPlacementValid = !this.isOverlappingInPlanter(this.plantPlacementPreview, this.activePlanter, ignore);
                    const color = this.isPlacementValid ? this.validPlacementColor : this.invalidPlacementColor;
                    this.plantPlacementPreview.traverse(c => { if (c.isMesh) c.material.color.set(color); });
                } else { this.plantPlacementPreview.visible = false; }
            }



            _handleMouseMoveFenceDrawing() {
                if (this.mode === 'DRAWING_FENCE' && this.fenceStartPoint) {
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObject(this.plot.ground);
                    if (intersects.length === 0) return;

                    const currentPoint = intersects[0].point;
                    const startPoint = this.fenceStartPoint;
                    let snappedEndPoint = this._findBestSnapPoint(currentPoint);

                    // --- AXIS SNAPPING LOGIC ---
                    // Only allow free angle if Shift is held
                    if (!this.isShiftDown) {
                        // Snap to X or Z axis (whichever is closer)
                        const delta = snappedEndPoint.clone().sub(startPoint);
                        if (Math.abs(delta.x) > Math.abs(delta.z)) {
                            // Snap to X axis
                            snappedEndPoint.z = startPoint.z;
                        } else {
                            // Snap to Z axis
                            snappedEndPoint.x = startPoint.x;
                        }
                    }

                    // Calculate fence properties directly from start and end points
                    const newWidth = startPoint.distanceTo(snappedEndPoint);
                    const newPosition = new THREE.Vector3().addVectors(startPoint, snappedEndPoint).multiplyScalar(0.5);
                    // Fix rotation calculation: use correct axis order for Y rotation
                    const finalRotationY = -Math.atan2(snappedEndPoint.z - startPoint.z, snappedEndPoint.x - startPoint.x);

                    // Update the preview with the calculated dimensions and position
                    const previewData = { ...this.temporaryPlacementConfig, width: Math.max(0.2, newWidth) };
                    this.updateGeneralPlacementPreview(previewData);

                    // Position and rotate the preview using calculated values
                    this.placementPreview.position.copy(newPosition);
                    this.placementPreview.rotation.y = finalRotationY;
                    this.placementPreview.visible = true;

                    if (this.debugBoxHelper) {
                        this.debugBoxHelper.visible = true;
                        // Update valid/invalid placement coloring
                        this.isPlacementValid = !this.isOverlapping(this.placementPreview);
                        const color = this.isPlacementValid ? this.validPlacementColor : this.invalidPlacementColor;
                        this.placementPreview.traverse(c => { if (c.isMesh) c.material.color.set(color); });
                        this.debugBoxHelper.update();
                    }
                }
            }



            onMouseMove(event) {
                if (event) { this.updateMouse(event); }
                switch (this.mode) {
                    case 'PLACEMENT': case 'MOVE': this._handleMouseMovePlacement(); break;
                    case 'PLANT_IN_PLANTER_PLACEMENT': case 'MOVE_PLANT_IN_PLANTER': this._handleMouseMovePlantInPlanter(); break;
                    case 'DRAWING_FENCE': this._handleMouseMoveFenceDrawing(); break;
                }
            }

            isOverlapping(previewObject) {
                const previewBox = new THREE.Box3().setFromObject(previewObject);
                // Shrink the box slightly to allow objects to be perfectly flush
                previewBox.expandByScalar(-0.01); 

                for (const obj of this.placedObjects) {
                    // Ignore the object we are currently moving
                    if (this.mode === 'MOVE' && obj === this.objectToMove) continue;

                    const existingBox = new THREE.Box3().setFromObject(obj);
                    if (previewBox.intersectsBox(existingBox)) {
                        // --- NEW: Exemption for snappable-to-snappable intersections ---
                        const isPreviewSnappable = previewObject.userData.dimensions?.snappable;
                        const isExistingSnappable = obj.userData.dimensions?.snappable;

                        if (isPreviewSnappable && isExistingSnappable) {
                            // Allow snappable items to touch/intersect to form junctions.
                            // By continuing, we ignore this intersection and check the next object.
                            continue; 
                        }
                        
                        // If it's not a snappable-to-snappable case (e.g., fence into a shed),
                        // then it's a real collision.
                        return true;
                    }
                }
                
                // If we looped through all objects without a critical collision, the placement is valid.
                return false;
            }

            isOverlappingInPlanter(preview, planter, ignore = null) {
                const previewBox = new THREE.Box3().setFromObject(preview);
                previewBox.expandByScalar(-0.01);
                for (const plant of planter.userData.plants || []) {
                    if (plant === ignore) continue;
                    if (previewBox.intersectsBox(new THREE.Box3().setFromObject(plant))) return true;
                }
                return false;
            }

            getEffectiveDimensions(dims, rotation) {
                const baseWidth = dims.originalWidth !== undefined ? dims.originalWidth : dims.width;
                const baseDepth = dims.originalDepth !== undefined ? dims.originalDepth : dims.depth;
                const baseHeight = dims.originalHeight !== undefined ? dims.originalHeight : dims.height;
                if (dims.isScalable) {
                    const growth = dims.growth !== undefined ? dims.growth : 1.0;
                    return { width: baseWidth * growth, depth: baseDepth * growth, height: baseHeight * growth };
                }
                const isRotated90or270 = Math.abs(Math.sin(rotation)) > 0.5;
                return { width: isRotated90or270 ? baseDepth : baseWidth, depth: isRotated90or270 ? baseWidth : baseDepth, height: baseHeight };
            }

            // --- START OF REPLACEMENT: Enhanced calculateSnapping Method ---
            calculateSnapping(point, data, rotation) {
                let finalPos = point.clone();
                let finalRot = rotation;
                const plotW = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const plotL = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const halfW = plotW / 2;
                const halfL = plotL / 2;
                let didSnap = false;

                // --- 1. Priority-based Snapping Logic ---

                // Highest Priority: Snapping to other Fences/Gates
                if (data.snappable) {
                    const objectSnapThreshold = 1.2;
                    let bestSnap = { distance: Infinity, position: null, rotation: null };

                    for (const existingObject of this.placedObjects) {
                        if (!existingObject.userData.dimensions.snappable || existingObject === this.objectToMove) continue;

                        // Get all potential snap points (endpoints and center)
                        const snapPoints = this._calculateEnhancedSnapPoints(existingObject);
                        
                        for (const snapPoint of snapPoints) {
                            const distance = point.distanceTo(snapPoint.position);
                            if (distance < objectSnapThreshold && distance < bestSnap.distance) {
                                // Calculate two potential positions for the new object's center
                                const newObjectOffset = new THREE.Vector3(data.width / 2, 0, 0).applyEuler(new THREE.Euler(0, snapPoint.rotation, 0));
                                const posSnapLeft = snapPoint.position.clone().add(newObjectOffset);
                                const posSnapRight = snapPoint.position.clone().sub(newObjectOffset);

                                // Find which potential placement is closer to the user's cursor
                                const distToSnapLeft = point.distanceTo(posSnapLeft);
                                const distToSnapRight = point.distanceTo(posSnapRight);

                                // Select the better position and use the snap point's rotation
                                const newPosition = (distToSnapLeft < distToSnapRight) ? posSnapLeft : posSnapRight;
                                
                                bestSnap = { 
                                    distance: distance, 
                                    position: newPosition, 
                                    rotation: snapPoint.rotation 
                                };
                            }
                        }
                    }
                    
                    if (bestSnap.position) {
                        finalPos.copy(bestSnap.position);
                        finalRot = bestSnap.rotation;
                        didSnap = true;
                    }
                }

                // Second Priority: Edge-snapping with automatic rotation
                if (!didSnap) {
                    const edgeSnapThreshold = 0.75;
                    let preferredEdge = null;
                    
                    if (Math.abs(point.x - halfW) < edgeSnapThreshold) preferredEdge = 'right';
                    else if (Math.abs(point.x + halfW) < edgeSnapThreshold) preferredEdge = 'left';
                    else if (Math.abs(point.z - halfL) < edgeSnapThreshold) preferredEdge = 'bottom';
                    else if (Math.abs(point.z + halfL) < edgeSnapThreshold) preferredEdge = 'top';

                    if (preferredEdge) {
                        // Automatically set rotation to be parallel to the edge
                        switch (preferredEdge) {
                            case 'right': case 'left':
                                finalRot = Math.PI / 2; // 90 degrees - vertical fence
                                break;
                            case 'bottom': case 'top':
                                finalRot = 0; // 0 degrees - horizontal fence
                                break;
                        }

                        // Get the dimensions for the new rotation
                        const dims = this.getEffectiveDimensions(data, finalRot);

                        // Snap position to edge, accounting for object size
                        switch (preferredEdge) {
                            case 'right': finalPos.x = halfW - dims.width / 2; break;
                            case 'left': finalPos.x = -halfW + dims.width / 2; break;
                            case 'bottom': finalPos.z = halfL - dims.depth / 2; break;
                            case 'top': finalPos.z = -halfL + dims.depth / 2; break;
                        }
                        
                        // Clamp the other axis to keep object within bounds
                        if (preferredEdge === 'left' || preferredEdge === 'right') {
                            finalPos.z = THREE.MathUtils.clamp(point.z, -halfL + dims.depth / 2, halfL - dims.depth / 2);
                        } else {
                            finalPos.x = THREE.MathUtils.clamp(point.x, -halfW + dims.width / 2, halfW - dims.width / 2);
                        }
                        didSnap = true;
                    }
                }


                // Fallback: Grid/Free Snapping
                if (!didSnap && this.controlsPanel.config.snapToGrid) {
                    const snapSize = this.controlsPanel.config.subdivisions;
                    finalPos.x = Math.round(point.x / snapSize) * snapSize;
                    finalPos.z = Math.round(point.z / snapSize) * snapSize;
                }

                // --- 2. Final Boundary Clamping ---
                const clampedResult = this._clampObjectToPlotBoundaries(finalPos, data, finalRot);
                
                return { position: clampedResult.position, rotation: finalRot };
            }

            _calculateEnhancedSnapPoints(object) {
                const snapPoints = [];
                const { width } = object.userData.dimensions;
                
                // Get object's world position and rotation
                const worldPos = object.position.clone();
                const worldRot = object.rotation.y;
                
                // Calculate endpoints in world space
                const leftEnd = new THREE.Vector3(-width / 2, 0, 0).applyEuler(new THREE.Euler(0, worldRot, 0)).add(worldPos);
                const rightEnd = new THREE.Vector3(width / 2, 0, 0).applyEuler(new THREE.Euler(0, worldRot, 0)).add(worldPos);
                const center = worldPos.clone();
                
                // Add snap points with their associated rotations
                snapPoints.push({ position: leftEnd, rotation: worldRot });
                snapPoints.push({ position: rightEnd, rotation: worldRot });
                snapPoints.push({ position: center, rotation: worldRot });
                
                return snapPoints;
            }

            _clampObjectToPlotBoundaries(position, data, rotation) {
                const plotW = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const plotL = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const halfW = plotW / 2;
                const halfL = plotL / 2;

                const objectDims = this.getEffectiveDimensions(data, rotation);
                const tempObject = new THREE.Object3D();
                tempObject.position.copy(position);
                tempObject.rotation.set(0, rotation, 0);
                tempObject.updateMatrixWorld();

                const localBox = new THREE.Box3();
                localBox.setFromCenterAndSize(
                    new THREE.Vector3(0, objectDims.height / 2, 0),
                    new THREE.Vector3(objectDims.width, objectDims.height, objectDims.depth || 0.1)
                );
                
                const worldBox = localBox.applyMatrix4(tempObject.matrixWorld);

                const overflowMinX = worldBox.min.x - (-halfW);
                const overflowMaxX = worldBox.max.x - halfW;
                const overflowMinZ = worldBox.min.z - (-halfL);
                const overflowMaxZ = worldBox.max.z - halfL;

                const clampedPosition = position.clone();
                if (overflowMinX < 0) clampedPosition.x -= overflowMinX;
                if (overflowMaxX > 0) clampedPosition.x -= overflowMaxX;
                if (overflowMinZ < 0) clampedPosition.z -= overflowMinZ;
                if (overflowMaxZ > 0) clampedPosition.z -= overflowMaxZ;

                return { position: clampedPosition };
            }
            // --- END OF REPLACEMENT ---

            calculatePlanterGridSnapping(localPoint, planter, plantConfig, rotation) {
                const soil = planter.children.find(c => c.name === 'planterSoil');
                if (!soil) return localPoint;
                const { innerDimensions: inner, dimensions: outer } = planter.userData;
                const halfW = inner.width/2, halfD = inner.depth/2;
                const plantDims = this.getEffectiveDimensions(plantConfig, rotation);
                let targetX = Math.round((localPoint.x + halfW) / (inner.width / outer.soilCols)) * (inner.width / outer.soilCols) - halfW;
                let targetZ = Math.round((localPoint.z + halfD) / (inner.depth / outer.soilRows)) * (inner.depth / outer.soilRows) - halfD;
                targetX = THREE.MathUtils.clamp(targetX, -halfW + plantDims.width/2, halfW - plantDims.width/2);
                targetZ = THREE.MathUtils.clamp(targetZ, -halfD + plantDims.depth/2, halfD - plantDims.depth/2);
                const soilTopY = soil.position.y + soil.geometry.parameters.height/2;
                return new THREE.Vector3(targetX, soilTopY, targetZ);
            }

            getPlanterLocalSoilPosition(localPoint, planter, plantConfig, rotation) {
                const soil = planter.children.find(c => c.name === 'planterSoil');
                if (!soil) return new THREE.Vector3(localPoint.x, 0, localPoint.z);
                const { innerDimensions: inner } = planter.userData;
                const halfW = inner.width / 2;
                const halfD = inner.depth / 2;
                const plantDims = this.getEffectiveDimensions(plantConfig, rotation);
                let targetX = THREE.MathUtils.clamp(localPoint.x, -halfW + plantDims.width/2, halfW - plantDims.width/2);
                let targetZ = THREE.MathUtils.clamp(localPoint.z, -halfD + plantDims.depth/2, halfD - plantDims.depth/2);
                const soilTopY = soil.position.y + soil.geometry.parameters.height/2;
                return new THREE.Vector3(targetX, soilTopY, targetZ);
            }
            
            _handleIdleClick(intersects) {
                if (intersects.length > 0) {
                    let hit = intersects[0].object, topLevel, plant;
                    let current = hit;
                    while(current) {
                        if (current.userData.isPlant) plant = current;
                        if (this.placedObjects.includes(current)) { topLevel = current; break; }
                        current = current.parent;
                    }
                    if (plant && topLevel?.userData.isPlanter) this.selectPlantInPlanter(plant, topLevel);
                    else if (topLevel) this.selectObject(topLevel);
                    else this.deselectObject();
                } else { this.deselectObject(); }
            }

            _handleClickPlacement() {
                if (this.placementPreview?.visible && this.isPlacementValid) {
                    this.placeObject(this.placementPreview.position);
                } else if (this.placementPreview && !this.isPlacementValid) {
                    this.infoPanel.show("Invalid Placement", "Cannot place here. Press Esc to cancel.", {text: "OK"});
                }
            }

            _handleClickMove() {
                if (this.placementPreview?.visible && this.isPlacementValid) {
                    this.exitMoveMode(true);
                } else if (this.placementPreview && !this.isPlacementValid) {
                    this.infoPanel.show("Invalid Placement", "Cannot move here. Press Esc to cancel.", {text: "OK"});
                }
            }

            _handleClickPlantInPlanterPlacement() {
                if (this.plantPlacementPreview?.visible && this.isPlacementValid) {
                    this.placePlantInPlanter(this.plantToPlaceInPlanterConfig, this.plantPlacementPreview.position, this.placementRotation);
                } else {
                    this.infoPanel.show("Invalid Placement", "Click on a valid spot. Press Esc to cancel.", {text: "OK"});
                }
            }

            onMouseDown(event) {
                 // All fence placement is handled through onMouseClick
            }

            onMouseUp(event) {
                // All fence placement is handled through onMouseClick
            }

            onMouseClick(event) {
                if (event.target.closest('.ui-panel, .tp-dfwv')) return;
                this.updateMouse(event);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const groundIntersects = this.raycaster.intersectObject(this.plot.ground);
                
                // --- Two-click draw system for fences/gates ---
                if (this.mode === 'PLACEMENT' && this.temporaryPlacementConfig && (this.temporaryPlacementConfig.name === 'Fence Section' || this.temporaryPlacementConfig.name === 'Gate')) {
                    if (groundIntersects.length === 0) return;
                    const clickPoint = groundIntersects[0].point;
                    
                    // First click: enter drawing mode, set start point
                    this.mode = 'DRAWING_FENCE';
                    this.fenceStartPoint = this._findBestSnapPoint(clickPoint);
                    this.controls.enabled = false;
                    this.updateGeneralPlacementPreview({ ...this.temporaryPlacementConfig, width: 0.2 });
                    this.placementPreview.position.copy(this.fenceStartPoint);
                    this.placementPreview.visible = true;
                    this.infoPanel.show('Drawing Fence', 'Move mouse to extend fence and click again to place. Press Esc to finish.');
                    return;
                }

                if (this.mode === 'DRAWING_FENCE') {
                    if (groundIntersects.length === 0) return;
                    const currentPoint = groundIntersects[0].point;
                    
                    // Second and subsequent clicks: finalize segment, continue drawing
                    const startPoint = this.fenceStartPoint;
                    let snappedEndPoint = this._findBestSnapPoint(currentPoint);
                    const finalWidth = startPoint.distanceTo(snappedEndPoint);
                    
                    if (finalWidth < 0.2) {
                        this.exitPlacementMode(); // Too short, treat as cancel
                        return;
                    }
                    
                    const finalPosition = new THREE.Vector3().addVectors(startPoint, snappedEndPoint).multiplyScalar(0.5);
                    const finalRotationY = -Math.atan2(snappedEndPoint.z - startPoint.z, snappedEndPoint.x - startPoint.x);
                    const finalItemData = { ...this.temporaryPlacementConfig, width: finalWidth };
                    
                    this._createAndPlaceObject(finalItemData, finalPosition, finalRotationY);
                    this.undoManager.saveState();
                    
                    // Continue drawing: set new start point
                    this.fenceStartPoint = snappedEndPoint.clone();
                    this.updateGeneralPlacementPreview({ ...this.temporaryPlacementConfig, width: 0.2 });
                    this.placementPreview.position.copy(this.fenceStartPoint);
                    this.placementPreview.visible = true;
                    this.infoPanel.show('Drawing Fence', 'Click to place next fence segment. Press Esc to finish.');
                    return;
                }

                // Handle other modes
                switch (this.mode) {
                    case 'IDLE':
                        const objectIntersects = this.raycaster.intersectObjects(this.placedObjects, true);
                        this._handleIdleClick(objectIntersects);
                        break;
                    case 'PLACEMENT': this._handleClickPlacement(); break;
                    case 'MOVE': this._handleClickMove(); break;
                    case 'PLANT_IN_PLANTER_PLACEMENT': this._handleClickPlantInPlanterPlacement(); break;
                    case 'MOVE_PLANT_IN_PLANTER':
                        if (this.plantPlacementPreview?.visible && this.isPlacementValid) { this.exitMovePlantInPlanterMode(true); }
                        else if (this.plantPlacementPreview && !this.isPlacementValid) { this.infoPanel.show("Invalid Move", "Cannot move plant here. Press Esc to cancel.", {text: "OK"}); }
                        break;
                }
            }

            onKeyDown(event) {
                // Ignore key events if an input field is focused
                if (event.target.matches('input[type="text"], input[type="number"]')) return;
                if (event.ctrlKey || event.metaKey) {
                    if (event.key.toLowerCase() === 'z') {
                        event.preventDefault();
                        this.undoManager.undo();
                    }
                    if (event.key.toLowerCase() === 'y') {
                        event.preventDefault();
                        this.undoManager.redo();
                    }
                }
                if (event.key.toLowerCase() === 'r') {
                    let preview = (this.mode === 'PLACEMENT' || this.mode === 'MOVE' || this.mode === 'DRAWING_FENCE') ? this.placementPreview : this.plantPlacementPreview;
                    if (preview?.visible) { this.placementRotation += Math.PI/2; this.onMouseMove(); }
                }
                if (event.key === 'Escape') {
                    if (this.mode === 'DRAWING_FENCE') {
                        this.exitPlacementMode();
                        this.infoPanel.hide();
                    }
                    else if (this.mode === 'PERIMETER_BUILD') this.exitPerimeterBuildMode();
                    else if (this.mode === 'MOVE_PLANT_IN_PLANTER') this.exitMovePlantInPlanterMode(false);
                    else if (this.mode.startsWith('PLANT')) this.exitPlantInPlanterSelectionMode();
                    else if (this.mode === 'PLACEMENT') this.exitPlacementMode();
                    else if (this.mode === 'MOVE') this.exitMoveMode(false);
                    else if (this.selectedObject) this.deselectObject();
                }
                if (event.key === 'Delete' || event.key === 'Backspace') {
                    if (this.selectedPlantInPlanter) this.removeSelectedPlantInPlanter();
                    else if (this.selectedObject) this.removeSelectedObject();
                }
            }
            
            setTheme(isDark) {
                this.currentTheme = isDark ? 'dark' : 'light';
                const theme = THEMES[this.currentTheme];
                const lightProps = {
                    hemiSky: isDark ? new THREE.Color(THEMES.dark.sky) : new THREE.Color(THEMES.light.gradientTop),
                    hemiGround: isDark ? new THREE.Color(THEMES.dark.ground) : new THREE.Color(THEMES.light.ground),
                    hemiIntensity: isDark ? 0.5 : 0.6,
                    sunIntensity: isDark ? 0.7 : 1.2,
                    sunColor: isDark ? new THREE.Color(0xb0c4de) : new THREE.Color(0xffefd5),
                };
                anime({ targets: this.hemiLight, intensity: lightProps.hemiIntensity, duration: 800, easing: 'easeInOutCubic' });
                anime({ targets: this.hemiLight.color, r: lightProps.hemiSky.r, g: lightProps.hemiSky.g, b: lightProps.hemiSky.b, duration: 800, easing: 'easeInOutCubic' });
                anime({ targets: this.hemiLight.groundColor, r: lightProps.hemiGround.r, g: lightProps.hemiGround.g, b: lightProps.hemiGround.b, duration: 800, easing: 'easeInOutCubic' });
                anime({ targets: this.sunLight, intensity: lightProps.sunIntensity, duration: 800, easing: 'easeInOutCubic' });
                anime({ targets: this.sunLight.color, r: lightProps.sunColor.r, g: lightProps.sunColor.g, b: lightProps.sunColor.b, duration: 800, easing: 'easeInOutCubic' });
                if (this.skyDome) {
                    this.skyDome.material.uniforms.topColor.value.set(theme.gradientTop);
                    this.skyDome.material.uniforms.bottomColor.value.set(theme.gradientBottom);
                }
                if (this.cloudGroup) {
                    this.cloudGroup.children.forEach(cloudSprite => {
                        if (cloudSprite.material) {
                            cloudSprite.material.color.set(isDark ? 0xAAAAAA : 0xFFFFFF);
                            cloudSprite.material.opacity = (Math.random() * 0.3 + 0.4) * (isDark ? 0.75 : 1.0);
                        }
                    });
                }
                this.controlsPanel.updatePlotFromUI();
                this.updateSunPosition(this.controlsPanel.config.timeOfDay); // Re-apply sun position for new theme
            }

            // --- NEW: SUN PATH SIMULATION ---
            updateSunPosition(time) {
                // Map time (5-21) to an angle (sunrise to sunset)
                const sunrise = 5, sunset = 21;
                const progress = (time - sunrise) / (sunset - sunrise);
                const angle = Math.PI * progress; // 0 to PI

                const sunDistance = 35;
                this.sunLight.position.set(
                    sunDistance * Math.cos(angle), // Moves from east (+) to west (-)
                    sunDistance * Math.sin(angle), // Moves up and then down
                    -15 // Keep it slightly to the "north" for better shadow angles
                );

                // Adjust light intensity and color based on time of day
                const peakIntensity = this.currentTheme === 'dark' ? 0.7 : 1.2;
                const intensity = Math.sin(angle) * peakIntensity; // Strongest at noon
                this.sunLight.intensity = intensity;

                const morningColor = new THREE.Color(0xffd8b8);
                const noonColor = this.currentTheme === 'dark' ? new THREE.Color(0xb0c4de) : new THREE.Color(0xffefd5);
                const eveningColor = new THREE.Color(0xffa07a);
                
                let sunColor = noonColor;
                if(progress < 0.5) {
                    sunColor = morningColor.clone().lerp(noonColor, progress * 2);
                } else {
                    sunColor = noonColor.clone().lerp(eveningColor, (progress - 0.5) * 2);
                }
                this.sunLight.color.set(sunColor);

                // Also adjust hemisphere light to be weaker when sun is low
                const peakHemiIntensity = this.currentTheme === 'dark' ? 0.5 : 0.6;
                this.hemiLight.intensity = (Math.sin(angle) * 0.5 + 0.5) * peakHemiIntensity;
            }

            goToTopView() {
                const plotWidthM = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const plotLengthM = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const maxDim = Math.max(plotWidthM, plotLengthM);
                const targetY = maxDim * 1.8;
                anime({ targets: this.camera.position, x: 0, y: targetY, z: 0.01, duration: 800, easing: 'easeInOutCubic',
                    update: () => { this.controls.target.set(0, 0, 0); this.controls.update(); }
                });
            }

            goToIsometricView() {
                this.isometricViewAngle += Math.PI / 2;
                if (this.isometricViewAngle >= Math.PI * 2) this.isometricViewAngle -= Math.PI * 2;
                this._updateIsometricCameraPosition(true); 
            }

            _updateIsometricCameraPosition(animated = false) {
                const plotWidthM = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const plotLengthM = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const maxDim = Math.max(plotWidthM, plotLengthM);
                const distance = maxDim * (this.baseIsometricDistanceFactor / this.controlsPanel.config.isometricZoom);
                const cameraProps = { x: distance * Math.cos(this.isometricViewAngle), y: distance * 0.8, z: distance * Math.sin(this.isometricViewAngle) };
                if (animated) {
                    anime({ targets: this.camera.position, ...cameraProps, duration: 800, easing: 'easeInOutCubic',
                        update: () => { this.controls.target.set(0, 0, 0); this.controls.update(); }
                    });
                } else {
                    this.camera.position.set(cameraProps.x, cameraProps.y, cameraProps.z);
                    this.controls.target.set(0, 0, 0);
                    this.controls.update();
                }
            }


            setViewLock(locked) { this.controls.enabled = !locked && this.mode === 'IDLE'; }
            setGridVisible(v) { if (this.plot.grid) this.plot.grid.visible = v; }
            setRulersVisible(v) { if (this.rulers?.container) this.rulers.container.visible = v; }
            setGridOpacity(v) { if (this.plot.grid) this.plot.grid.material.opacity = v; }
            setRulerOpacity(v) { if (this.rulers?.container) this.rulers.container.traverse(c => { if(c.material) c.material.opacity = v; }); }
            onResize() {
                const { clientWidth, clientHeight } = this.renderer.domElement.parentElement;
                this.camera.aspect = clientWidth / clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(clientWidth, clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                if (this.axisIndicator) {
                    this.axisIndicator.onResize();
                }
            }

            createObjectLabelSprite(object) {
                if (!object.name) return null;
                const text = object.name;
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const fontSize = 28;
                context.font = `bold ${fontSize}px Arial`;
                const textWidth = context.measureText(text).width;
                canvas.width = textWidth + 20; canvas.height = fontSize + 10;
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = 'rgba(40, 40, 40, 0.8)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = '#eee'; context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, opacity: 0.9, alphaTest: 0.1 });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(canvas.width * 0.003, canvas.height * 0.003, 1.0);
                sprite.userData.baseScale = sprite.scale.clone();
                let line = null;
                if (object.userData.isPlant) {
                    const lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x999999, transparent: true, opacity: 0.7 });
                    line = new THREE.LineSegments(lineGeometry, lineMaterial);
                }
                return { obj: object, sprite: sprite, line: line };
            }
            
            _worldPositionHelper = new THREE.Vector3();
            _objectTopWorldPosition = new THREE.Vector3();
            _spriteWorldPosition = new THREE.Vector3();
            _tempLocalStart = new THREE.Vector3();
            _tempLocalEnd = new THREE.Vector3();
            _objectBoundingBox = new THREE.Box3();

            updateLoopLabels() {
                if (!this.showLabels) {
                    this.labelSprites.forEach(spriteData => {
                        if (spriteData.sprite) spriteData.sprite.visible = false;
                        if (spriteData.line) spriteData.line.visible = false;
                    });
                    return;
                }
                const cameraPosition = this.camera.position;
                this.labelSprites.forEach(({ obj, sprite, line }) => {
                    if (!obj.parent) {
                        this.allObjectLabels.remove(sprite);
                        disposeObject(sprite);
                        if (line) {
                            this.allObjectLabels.remove(line);
                            disposeObject(line);
                        }
                        this.labelSprites.delete(obj.uuid);
                        return;
                    }
                    sprite.visible = true;
                    this._objectBoundingBox.setFromObject(obj);
                    this._objectBoundingBox.getCenter(this._worldPositionHelper);

                    this._objectTopWorldPosition.set(this._worldPositionHelper.x, this._objectBoundingBox.max.y, this._worldPositionHelper.z);
                    
                    const labelYOffset = 0.2; 
                    sprite.position.copy(this._objectTopWorldPosition).add(new THREE.Vector3(0, labelYOffset, 0));
                    const distance = sprite.position.distanceTo(cameraPosition);
                    const scaleFactor = distance / 18;
                    sprite.scale.copy(sprite.userData.baseScale).multiplyScalar(scaleFactor);
                    if (line) {
                        line.visible = true;
                        const positions = line.geometry.attributes.position;
                        const lineStartWorld = this._objectTopWorldPosition; 
                        sprite.getWorldPosition(this._spriteWorldPosition);
                        const lineEndWorld = this._spriteWorldPosition;
                        this.allObjectLabels.worldToLocal(lineStartWorld.clone(), this._tempLocalStart);
                        this.allObjectLabels.worldToLocal(lineEndWorld.clone(), this._tempLocalEnd);
                        positions.setXYZ(0, this._tempLocalStart.x, this._tempLocalStart.y, this._tempLocalStart.z);
                        positions.setXYZ(1, this._tempLocalEnd.x, this._tempLocalEnd.y, this._tempLocalEnd.z);
                        positions.needsUpdate = true;
                    }
                });
            }

            // --- START: Add these two new methods to the World class ---

            _createDimensionLabelSprite(text) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const fontSize = 48; // Larger font for clarity
                context.font = `bold ${fontSize}px Arial`;
                const textWidth = context.measureText(text).width;
                
                canvas.width = textWidth + 24; // Add padding
                canvas.height = fontSize + 16;
                
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = '#FFFFFF';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(canvas.width * 0.0025, canvas.height * 0.0025, 1.0);
                return sprite;
            }

            _updateDimensionLabels() {
                if (!this.selectedObject) return;

                // Clear existing labels
                while (this.dimensionLabelGroup.children.length) {
                    disposeObject(this.dimensionLabelGroup.children[0]);
                    this.dimensionLabelGroup.remove(this.dimensionLabelGroup.children[0]);
                }

                const dims = this.selectedObject.userData.dimensions;
                const unitKey = this.controlsPanel.config.units;
                const unitInfo = UNITS[unitKey];

                const convert = (val) => (val * unitInfo.factor).toFixed(1);

                // Get rotated dimensions for accurate labeling
                const effectiveDims = this.getEffectiveDimensions(dims, this.selectedObject.rotation.y);

                const labels = {
                    width: this._createDimensionLabelSprite(`${convert(effectiveDims.width)} ${unitInfo.symbol}`),
                    height: this._createDimensionLabelSprite(`${convert(dims.height)} ${unitInfo.symbol}`),
                    depth: this._createDimensionLabelSprite(`${convert(effectiveDims.depth)} ${unitInfo.symbol}`),
                };

                labels.width.name = 'widthLabel';
                labels.height.name = 'heightLabel';
                labels.depth.name = 'depthLabel';

                this.dimensionLabelGroup.add(labels.width, labels.height, labels.depth);
                this.dimensionLabelGroup.visible = true;
            }

            // --- END: Add these two new methods to the World class ---

            // --- START: Add this new method to the World class ---

            _updateDimensionLabelPositions() {
                if (!this.selectedObject || !this.dimensionLabelGroup.visible) return;

                // Use the actual selection box helper's bounding box for positioning
                const box = new THREE.Box3().setFromObject(this.selectionBox);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                const widthLabel = this.dimensionLabelGroup.getObjectByName('widthLabel');
                const heightLabel = this.dimensionLabelGroup.getObjectByName('heightLabel');
                const depthLabel = this.dimensionLabelGroup.getObjectByName('depthLabel');

                // Position labels on the midpoint of the bounding box edges
                if (widthLabel) widthLabel.position.set(center.x, box.max.y + 0.1, center.z);
                if (heightLabel) heightLabel.position.set(box.min.x - 0.1, center.y, center.z);
                if (depthLabel) depthLabel.position.set(center.x, center.y, box.min.z - 0.1);
            }

            // --- END: Add this new method to the World class ---

            updateAllObjectLabelsVisibility() {
                this.showLabels = this.controlsPanel.config.showLabels;
                this.labelSprites.forEach(spriteData => {
                    this.allObjectLabels.remove(spriteData.sprite);
                    disposeObject(spriteData.sprite);
                    if (spriteData.line) { this.allObjectLabels.remove(spriteData.line); disposeObject(spriteData.line); }
                });
                this.labelSprites.clear();
                if (this.showLabels) {
                    const addLabelForObj = (obj) => {
                        const labelData = this.createObjectLabelSprite(obj);
                        if (labelData) {
                            this.allObjectLabels.add(labelData.sprite);
                            if (labelData.line) this.allObjectLabels.add(labelData.line);
                            this.labelSprites.set(obj.uuid, labelData);
                        }
                    };
                    this.placedObjects.forEach(obj => {
                        addLabelForObj(obj);
                        if (obj.userData.isPlanter && obj.userData.plants) { obj.userData.plants.forEach(plant => addLabelForObj(plant)); }
                    });
                }
            }

            togglePlantSummaryPanel() {
                const isNowHidden = this.plantSummaryPanel.classList.toggle('hidden');
                if (!isNowHidden) this.updatePlantSummaryPanel();
            }

            updatePlantSummaryPanel() {
                let totalIndividualPlants = 0; 
                const aggregatedPlants = new Map();
                this.placedObjects.forEach(obj => {
                    if (obj.userData.isPlanter && obj.userData.plants) {
                        obj.userData.plants.forEach(plant => {
                            totalIndividualPlants++; 
                            const plantName = plant.name;
                            const planterName = obj.name; 
                            const originalPlantDef = Object.values(PLANTS).flat().find(p => p.name === plantName);
                            if (!aggregatedPlants.has(plantName)) { aggregatedPlants.set(plantName, { count: 0, planterNames: new Set(), plantDefinition: originalPlantDef }); }
                            const entry = aggregatedPlants.get(plantName);
                            entry.count++;
                            entry.planterNames.add(planterName);
                        });
                    }
                });
                let tableBodyHtml = '';
                const sortedPlantNames = Array.from(aggregatedPlants.keys()).sort();
                sortedPlantNames.forEach(plantName => {
                    const entry = aggregatedPlants.get(plantName);
                    const plantDef = entry.plantDefinition; 
                    const planterList = Array.from(entry.planterNames).join(', ') || '-';
                    tableBodyHtml += `<tr><td>${plantName} (${entry.count})</td><td>${planterList}</td><td>${plantDef?.typicalSizeStr || '-'}</td><td>${plantDef?.light || '-'}</td><td>${(plantDef?.avgWaterLitersPerWeek !== undefined && plantDef.avgWaterLitersPerWeek !== null) ? `${plantDef.avgWaterLitersPerWeek}L` : '-'}</td><td>${plantDef?.yield || '-'}</td><td>${plantDef?.avgGrowthTime || '-'}</td><td>${plantDef?.sowTime || '-'}</td><td>${plantDef?.harvestTime || '-'}</td></tr>`;
                });
                let panelContent = `<h3>Plant Summary</h3>`;
                if (totalIndividualPlants === 0) { panelContent += `<p>No plants currently placed in planters.</p>`; }
                else { panelContent += `<table><thead><tr><th>Plant</th><th>In Planter</th><th>Space Needed</th><th>Light</th><th>Water (L/week)</th><th>Typical Yield</th><th>Avg. Growth</th><th>Sow Time</th><th>Harvest Time</th></tr></thead><tbody>${tableBodyHtml}</tbody></table><p>Total Individual Plants in Planters: ${totalIndividualPlants}</p>`; }
                this.plantSummaryPanel.innerHTML = panelContent;
            }
            
            exportPlantSummary() {
                let totalIndividualPlants = 0;
                const aggregatedPlants = new Map();
                this.placedObjects.forEach(obj => {
                    if (obj.userData.isPlanter && obj.userData.plants) {
                        obj.userData.plants.forEach(plant => {
                            totalIndividualPlants++; const plantName = plant.name; const planterName = obj.name;
                            const originalPlantDef = Object.values(PLANTS).flat().find(p => p.name === plantName);
                            if (!aggregatedPlants.has(plantName)) { aggregatedPlants.set(plantName, { count: 0, planterNames: new Set(), plantDefinition: originalPlantDef }); }
                            const entry = aggregatedPlants.get(plantName); entry.count++; entry.planterNames.add(planterName);
                        });
                    }
                });
                let tableRows = '';
                const sortedPlantNames = Array.from(aggregatedPlants.keys()).sort();
                sortedPlantNames.forEach(plantName => {
                    const entry = aggregatedPlants.get(plantName); const plantDef = entry.plantDefinition;
                    const planterList = Array.from(entry.planterNames).join(', ') || '-';
                    tableRows += `<tr><td>${plantName} (${entry.count})</td><td>${planterList}</td><td>${plantDef?.typicalSizeStr || '-'}</td><td>${plantDef?.light || '-'}</td><td>${(plantDef?.avgWaterLitersPerWeek !== undefined && plantDef.avgWaterLitersPerWeek !== null) ? `${plantDef.avgWaterLitersPerWeek}L` : '-'}</td><td>${plantDef?.yield || '-'}</td><td>${plantDef?.avgGrowthTime || '-'}</td><td>${plantDef?.sowTime || '-'}</td><td>${plantDef?.harvestTime || '-'}</td></tr>`;
                });
                const htmlContent = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Plant Summary</title><style>body{font-family:sans-serif;margin:20px}h1{border-bottom:2px solid #2C3E50;padding-bottom:10px}table{width:100%;border-collapse:collapse;margin-top:20px}th,td{border:1px solid #ddd;padding:8px;text-align:left}th{background-color:#f2f2f2}</style></head><body><h1>Allotment Plant Summary</h1>${totalIndividualPlants === 0 ? '<p>No plants.</p>' : `<table><thead><tr><th>Plant</th><th>In Planter</th><th>Space Needed</th><th>Light</th><th>Water (L/week)</th><th>Typical Yield</th><th>Avg. Growth</th><th>Sow Time</th><th>Harvest Time</th></tr></thead><tbody>${tableRows}</tbody></table><p>Total Plants: ${totalIndividualPlants}</p>`}<p>Generated on ${new Date().toLocaleDateString()}.</p></body></html>`;
                const blob = new Blob([htmlContent], { type: "text/html" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = "allotment_plant_summary.html";
                document.body.appendChild(a); a.click(); document.body.removeChild(a); 
                URL.revokeObjectURL(a.href);
                this.infoPanel.show("Export Complete", "Plant summary saved.", { text: "OK" });
            }

            getCurrentLayoutData() {
                return {
                    objects: this.placedObjects.map(obj => ({
                        name: obj.name, pos: obj.position.toArray(), rotY: obj.rotation.y, dims: obj.userData.dimensions,
                        plants: obj.userData.plants?.map(p => ({ name: p.name, localPos: p.position.toArray(), rotY: p.rotation.y, dims: p.userData.dimensions }))
                    })),
                    config: this.controlsPanel.config, version: "1.2" // Version bump
                };
            }
            saveLayout() { localStorage.setItem('allotmentLayout', JSON.stringify(this.getCurrentLayoutData())); this.infoPanel.show("Layout Saved", "Saved to browser storage.", {text: "OK"}); }
            loadLayout() { const data = localStorage.getItem('allotmentLayout'); if(data) this.rebuildSceneFromData(JSON.parse(data), "Loaded"); else this.infoPanel.show("Load Failed", "No layout found.", {text: "OK"}); }
            exportLayout() { const blob = new Blob([JSON.stringify(this.getCurrentLayoutData(), null, 2)], { type: "application/json" }); const a = document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="allotment-layout.json"; a.click(); a.remove(); this.infoPanel.show("Export Complete", "Layout saved.", {text: "OK"}); }

            rebuildSceneFromData(saveData, source) {
                this.undoManager.isUndoingOrRedoing = true; // Prevent saving this action to undo stack
                try {
                    this.clearSceneObjects(true); // Pass true to prevent clearing undo stack
                    saveData.objects?.forEach(item => {
                        const originalDef = STRUCTURES.find(s => s.name === item.name) || Object.values(PLANTS).flat().find(p => p.name === item.name);
                        if (!originalDef) { console.warn(`Definition not found for item: ${item.name}`); return; }
                        const itemDimensions = { ...originalDef, ...item.dims,
                            originalWidth: item.dims.originalWidth ?? originalDef.width,
                            originalDepth: item.dims.originalDepth ?? originalDef.depth,
                            originalHeight: item.dims.originalHeight ?? originalDef.height,
                        };
                        const newObject = this._createAndPlaceObject(itemDimensions, new THREE.Vector3().fromArray(item.pos), item.rotY);
                        if (itemDimensions.isHollow && item.plants) {
                            newObject.userData.plants = []; 
                            this._rebuildPlanterPlantsFromData(newObject, item.plants);
                        }
                    });
                    if (saveData.config) {
                        for (const key in saveData.config) {
                            if (this.controlsPanel.config.hasOwnProperty(key)) { this.controlsPanel.config[key] = saveData.config[key]; }
                        }
                        this.controlsPanel.onUnitsChange(saveData.config.units); 
                        this.setTheme(saveData.config.darkMode);
                        this.setViewLock(saveData.config.viewLocked);
                        this.controlsPanel.pane.refresh();
                        this._updateIsometricCameraPosition(false);
                        this.updateSunPosition(saveData.config.timeOfDay || 12.0); // Restore sun position
                    }
                    this.updateAllObjectLabelsVisibility();
                    if (source !== "Undo" && source !== "Redo") {
                        this.infoPanel.show(`Layout ${source}`, `Layout and settings restored.`, {text: "OK"});
                    }
                    this.updatePlantSummaryPanel(); 
                } catch (e) {
                    console.error("Error rebuilding scene:", e);
                    this.infoPanel.show(`Error`, `Failed to process layout. ${e.message}`, {text: "OK"});
                } finally {
                    this.undoManager.isUndoingOrRedoing = false;
                    // If this is a fresh load/import, clear history and save it as the new initial state
                    if (source !== "Undo" && source !== "Redo") {
                        this.undoManager.clear();
                    }
                }
            }

            updateObjectDimensions(object, newDimensions, newPosition) {
                const oldRotation = object.rotation.clone(); // Preserve rotation
                const originalDef = STRUCTURES.find(s => s.name === object.name) || Object.values(PLANTS).flat().find(p => p.name === object.name);
                const updatedDef = { ...originalDef, ...newDimensions };

                // Rebuild the mesh with new dimensions
                while(object.children.length > 0){ 
                    disposeObject(object.children[0]);
                    object.remove(object.children[0]); 
                }
                const newMeshGroup = this._createMeshFromDefinition(updatedDef);
                newMeshGroup.children.forEach(child => object.add(child.clone()));
                
                // Set the new data and apply the new absolute position
                object.userData.dimensions = updatedDef;
                object.position.copy(newPosition); 
                object.rotation.copy(oldRotation);
                
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // The handles themselves need to be updated after the object is changed
                this.resizeHandles.update();

                if (this.selectedObject === object) {
                    this._updateDimensionLabels(); // <-- ADD THIS LINE
                    this.createObjectEditor();
                }
            }

            // --- PERIMETER FENCE GENERATOR METHODS ---
            
            togglePerimeterPanel() {
                if (this.perimeterPane) {
                    this.perimeterPane.dispose();
                    this.perimeterPane = null;
                    this.rightToolPanelContainer.classList.add('hidden');
                } else {
                    this.createPerimeterPanel();
                }
            }

            createPerimeterPanel() {
                this.perimeterPane = this._initRightToolPanel('Perimeter Fence');
                if (!this.perimeterPane) return;
                
                // Top Edge Folder
                const topFolder = this.perimeterPane.addFolder({ title: 'Top Edge' });
                topFolder.addInput(this.perimeterConfig, 'topEdge', { label: 'Enable' });
                topFolder.addInput(this.perimeterConfig, 'topGate_Left', { label: 'Left Gate' });
                topFolder.addInput(this.perimeterConfig, 'topGate_Center', { label: 'Center Gate' });
                topFolder.addInput(this.perimeterConfig, 'topGate_Right', { label: 'Right Gate' });
                
                // Bottom Edge Folder
                const bottomFolder = this.perimeterPane.addFolder({ title: 'Bottom Edge' });
                bottomFolder.addInput(this.perimeterConfig, 'bottomEdge', { label: 'Enable' });
                bottomFolder.addInput(this.perimeterConfig, 'bottomGate_Left', { label: 'Left Gate' });
                bottomFolder.addInput(this.perimeterConfig, 'bottomGate_Center', { label: 'Center Gate' });
                bottomFolder.addInput(this.perimeterConfig, 'bottomGate_Right', { label: 'Right Gate' });
                
                // Left Edge Folder
                const leftFolder = this.perimeterPane.addFolder({ title: 'Left Edge' });
                leftFolder.addInput(this.perimeterConfig, 'leftEdge', { label: 'Enable' });
                leftFolder.addInput(this.perimeterConfig, 'leftGate_Left', { label: 'Left Gate' });
                leftFolder.addInput(this.perimeterConfig, 'leftGate_Center', { label: 'Center Gate' });
                leftFolder.addInput(this.perimeterConfig, 'leftGate_Right', { label: 'Right Gate' });
                
                // Right Edge Folder
                const rightFolder = this.perimeterPane.addFolder({ title: 'Right Edge' });
                rightFolder.addInput(this.perimeterConfig, 'rightEdge', { label: 'Enable' });
                rightFolder.addInput(this.perimeterConfig, 'rightGate_Left', { label: 'Left Gate' });
                rightFolder.addInput(this.perimeterConfig, 'rightGate_Center', { label: 'Center Gate' });
                rightFolder.addInput(this.perimeterConfig, 'rightGate_Right', { label: 'Right Gate' });
                
                // Generate Button
                this.perimeterPane.addButton({
                    title: '✅ Generate Perimeter',
                    label: 'Create Fence'
                }).on('click', () => this.generatePerimeterFence());
            }

            generatePerimeterFence() {
                // Remove previous perimeter fences
                const toRemove = this.placedObjects.filter(obj => obj.userData.isPerimeterFence);
                toRemove.forEach(obj => this._removeObjectAndCleanup(obj));
                
                // Get plot size
                const width = convertToMeters(this.controlsPanel.config.width, this.controlsPanel.config.units);
                const length = convertToMeters(this.controlsPanel.config.length, this.controlsPanel.config.units);
                const fenceDef = STRUCTURES.find(s => s.name === 'Fence Section');
                const gateDef = STRUCTURES.find(s => s.name === 'Gate');
                
                const halfW = width / 2;
                const halfL = length / 2;

                // Top
                if (this.perimeterConfig.topEdge) {
                    this._processEdgeWithMultiGates( new THREE.Vector3(-halfW, 0, -halfL), new THREE.Vector3(halfW, 0, -halfL), 0, 'top', fenceDef, gateDef );
                }
                // Bottom
                if (this.perimeterConfig.bottomEdge) {
                    this._processEdgeWithMultiGates( new THREE.Vector3(-halfW, 0, halfL), new THREE.Vector3(halfW, 0, halfL), Math.PI, 'bottom', fenceDef, gateDef );
                }
                // Left
                if (this.perimeterConfig.leftEdge) {
                    this._processEdgeWithMultiGates( new THREE.Vector3(-halfW, 0, halfL), new THREE.Vector3(-halfW, 0, -halfL), Math.PI / 2, 'left', fenceDef, gateDef );
                }
                // Right
                if (this.perimeterConfig.rightEdge) {
                    this._processEdgeWithMultiGates( new THREE.Vector3(halfW, 0, -halfL), new THREE.Vector3(halfW, 0, halfL), -Math.PI / 2, 'right', fenceDef, gateDef );
                }
                this.undoManager.saveState();
                this.infoPanel.show('Perimeter Fence Generated', 'Your perimeter fence has been created successfully!');
            }

            _processEdgeWithMultiGates(startPoint, endPoint, rotation, edgeName, fenceDef, gateDef) {
                // Helper for event points
                function lerpVec3(a, b, t) {
                    return new THREE.Vector3(
                        a.x + (b.x - a.x) * t,
                        a.y + (b.y - a.y) * t,
                        a.z + (b.z - a.z) * t
                    );
                }
                const eventPoints = [];
                eventPoints.push({ position: startPoint.clone(), type: 'start' });
                const edgeLength = startPoint.distanceTo(endPoint);
                const gateWidth = gateDef.width;
                // Gates at 25%, 50%, 75%
                const gateKeys = [
                    { key: edgeName + 'Gate_Left', t: 0.25 },
                    { key: edgeName + 'Gate_Center', t: 0.5 },
                    { key: edgeName + 'Gate_Right', t: 0.75 }
                ];
                for (const g of gateKeys) {
                    if (this.perimeterConfig[g.key]) {
                        // Gate start/end
                        const gateStart = lerpVec3(startPoint, endPoint, g.t - gateWidth/(2*edgeLength));
                        const gateEnd = lerpVec3(startPoint, endPoint, g.t + gateWidth/(2*edgeLength));
                        eventPoints.push({ position: gateStart, type: 'gate_start' });
                        eventPoints.push({ position: gateEnd, type: 'gate_end' });
                    }
                }
                eventPoints.push({ position: endPoint.clone(), type: 'end' });
                // Sort
                if (edgeName === 'top' || edgeName === 'bottom') {
                    eventPoints.sort((a, b) => Math.sign(endPoint.x - startPoint.x) * (a.position.x - b.position.x));
                } else {
                    eventPoints.sort((a, b) => Math.sign(endPoint.z - startPoint.z) * (a.position.z - b.position.z));
                }
                // Place objects
                for (let i = 0; i < eventPoints.length - 1; i++) {
                    const curr = eventPoints[i];
                    const next = eventPoints[i+1];
                    const segmentLen = curr.position.distanceTo(next.position);
                    
                    // If gate
                    if (curr.type === 'gate_start' && next.type === 'gate_end') {
                        const gatePos = curr.position.clone().lerp(next.position, 0.5);
                        const gateObj = this._createAndPlaceObject(gateDef, gatePos, rotation);
                        gateObj.userData.isPerimeterFence = true;
                        continue;
                    }
                    // Fence fill
                    if (segmentLen > 0.1) {
                        const numFences = Math.ceil(segmentLen / fenceDef.width);
                        const actualFenceWidth = segmentLen / numFences;
                        for (let j = 0; j < numFences; j++) {
                            const fencePos = curr.position.clone().lerp(next.position, (j + 0.5) / numFences);
                            const fenceData = { ...fenceDef, width: actualFenceWidth };
                            const fenceObj = this._createAndPlaceObject(fenceData, fencePos, rotation);
                            fenceObj.userData.isPerimeterFence = true;
                        }
                    }
                }
            }

            toggleAxisIndicator(show) {
                this.axisIndicatorVisible = show;
                this.axisIndicatorContainer.style.display = show ? 'block' : 'none';
            }
            addPlotAxisWidget() {
                // Remove old children
                while (this.axisWidgetGroup.children.length > 0) {
                    this.axisWidgetGroup.remove(this.axisWidgetGroup.children[0]);
                }
                // Get plot size and position
                const plot = this.plot.ground;
                plot.updateMatrixWorld();
                const geometry = plot.geometry;
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                // Find the corner closest to the camera
                const cameraPosition = this.camera.position;
                const corners = [
                    new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z), // -X, -Y, -Z
                    new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.min.z), // +X, -Y, -Z
                    new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.min.z), // -X, +Y, -Z
                    new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.min.z), // +X, +Y, -Z
                    new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.max.z), // -X, -Y, +Z
                    new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.max.z), // +X, -Y, +Z
                    new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.max.z), // -X, +Y, +Z
                    new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.max.z)  // +X, +Y, +Z
                ];
                let closestCorner = null;
                let minDistance = Infinity;
                corners.forEach(corner => {
                    const worldCorner = corner.applyMatrix4(plot.matrixWorld);
                    const distance = cameraPosition.distanceTo(worldCorner);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCorner = worldCorner;
                    }
                });
                // Axis parameters
                const axisLength = 1.2; // Length of each axis line
                const arrowLength = 0.18; // Length of arrowhead
                const arrowRadius = 0.06; // Radius of arrowhead base
                // Calculate direction vectors from corner to plot center
                const plotCenter = new THREE.Vector3();
                geometry.boundingBox.getCenter(plotCenter);
                plotCenter.applyMatrix4(plot.matrixWorld);
                const toCenter = plotCenter.clone().sub(closestCorner).normalize();
                // Project toCenter onto X and Z axes to get axis directions
                let xDir = new THREE.Vector3(toCenter.x, 0, 0);
                let yDir = new THREE.Vector3(0, 1, 0); // Y always up
                let zDir = new THREE.Vector3(0, 0, toCenter.z);
                // If the corner is exactly at the center in X or Z, fallback to +X or -Z
                if (xDir.lengthSq() === 0) {
                    xDir.set(1, 0, 0);
                    console.warn('Axis widget: xDir was zero-length, defaulting to +X');
                }
                if (zDir.lengthSq() === 0) {
                    zDir.set(0, 0, -1);
                    console.warn('Axis widget: zDir was zero-length, defaulting to -Z');
                }
                xDir.normalize();
                zDir.normalize();
                // Axis directions and colors
                const axes = [
                    { dir: xDir, color: 0xFF7777, label: 'X' },
                    { dir: yDir, color: 0x77FF77, label: 'Y' },
                    { dir: zDir, color: 0x7777FF, label: 'Z' },
                ];
                // Build axes in local space, then move group to closestCorner
                for (const axis of axes) {
                    // Line
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        axis.dir.clone().multiplyScalar(axisLength)
                    ]);
                    const lineMat = new THREE.LineBasicMaterial({ color: axis.color });
                    const line = new THREE.Line(lineGeom, lineMat);
                    this.axisWidgetGroup.add(line);
                    // Arrowhead (cone)
                    const axisDir = axis.dir.clone().normalize();
                    const coneGeom = new THREE.ConeGeometry(arrowRadius, arrowLength, 16);
                    const coneMat = new THREE.MeshBasicMaterial({ color: axis.color });
                    const cone = new THREE.Mesh(coneGeom, coneMat);
                    // By default, cone points +Y, so rotate to axisDir
                    const defaultDir = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultDir, axisDir);
                    cone.quaternion.copy(quaternion);
                    // Move cone so its base is at the end of the line
                    cone.position.copy(axis.dir.clone().multiplyScalar(axisLength + arrowLength / 2));
                    this.axisWidgetGroup.add(cone);
                    // Label (move to end of axis, next to arrow)
                    const labelOffset = axis.dir.clone().multiplyScalar(axisLength + arrowLength * 0.7);
                    const label = this.createBillboardLabel(axis.label, labelOffset, `#${axis.color.toString(16).padStart(6, '0')}`);
                    this.axisWidgetGroup.add(label);
                }
                // Move the whole group to the closest corner
                this.axisWidgetGroup.position.copy(closestCorner);
            }
            createBillboardLabel(text, position, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                context.font = 'bold 48px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(position);
                sprite.scale.set(0.5, 0.25, 1);
                sprite.userData.isAxisLabel = true;
                return sprite;
            }
        }

        // --- START OF REPLACEMENT: Completely Rewritten ResizeHandles Class ---
            class ResizeHandles {
                constructor(world, camera, domElement, controls, onResizeCallback) {
                    this.world = world;
                    this.camera = camera;
                    this.domElement = domElement;
                    this.controls = controls;
                    this.onResizeCallback = onResizeCallback;

                    this.handles = new THREE.Group();
                    this.raycaster = new THREE.Raycaster();
                    this.mouse = new THREE.Vector2();

                    this.activeHandle = null;
                    this.attachedObject = null;
                    this.dragPlane = new THREE.Plane();
                    
                    // State for anchor-based resizing
                    this.dragStartWorld = new THREE.Vector3();
                    this.handleAxisWorld = new THREE.Vector3();
                    this.objectStartPos = new THREE.Vector3();
                    this.objectStartDims = {};
                    this.anchorPoint = new THREE.Vector3(); // The point that stays fixed during resize

                    this._createHandles();
                    this.handles.visible = false;

                    this.domElement.addEventListener('mousedown', this._onMouseDown.bind(this), false);
                    this.domElement.addEventListener('mousemove', this._onMouseMove.bind(this), false);
                    this.domElement.addEventListener('mouseup', this._onMouseUp.bind(this), false);
                }

                _createHandles() {
                    // Use a box for better visibility and grabbing
                    const handleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.95, depthTest: false });
                    
                    // Define handles based on their axis and direction
                    const handleDefs = [
                        { name: 'right',  axis: new THREE.Vector3( 1, 0, 0) },
                        { name: 'left',   axis: new THREE.Vector3(-1, 0, 0) },
                        { name: 'top',    axis: new THREE.Vector3( 0, 1, 0) },
                        { name: 'bottom', axis: new THREE.Vector3( 0,-1, 0) },
                        { name: 'front',  axis: new THREE.Vector3( 0, 0, 1) },
                        { name: 'back',   axis: new THREE.Vector3( 0, 0,-1) },
                    ];
                    
                    handleDefs.forEach(def => {
                        const handle = new THREE.Mesh(handleGeometry, handleMaterial.clone());
                        handle.name = def.name;
                        handle.userData.axis = def.axis;
                        this.handles.add(handle);
                    });
                }

                attach(object) {
                    this.attachedObject = object;
                    this.update();
                    this.handles.visible = true;
                }

                detach() {
                    if (this.activeHandle) this._onMouseUp();
                    this.attachedObject = null;
                    this.handles.visible = false;
                }

                update() {
                    if (!this.attachedObject) return;
                    
                    const { width, height, depth } = this.attachedObject.userData.dimensions;
                    const visualDepth = depth || 0.1;

                    // The handles group should match the object's transform
                    this.attachedObject.getWorldPosition(this.handles.position);
                    this.attachedObject.getWorldQuaternion(this.handles.quaternion);

                    // Position handles relative to the group's center
                    this.handles.getObjectByName('right').position.set(width / 2, height / 2, 0);
                    this.handles.getObjectByName('left').position.set(-width / 2, height / 2, 0);
                    this.handles.getObjectByName('top').position.set(0, height, 0);
                    this.handles.getObjectByName('bottom').position.set(0, 0, 0);
                    this.handles.getObjectByName('front').position.set(0, height / 2, visualDepth / 2);
                    this.handles.getObjectByName('back').position.set(0, height / 2, -visualDepth / 2);
                }

                _onMouseDown(event) {
                    if (event.target.closest('.ui-panel, .tp-dfwv') || !this.handles.visible || this.activeHandle) return;

                    this.mouse.set((event.clientX / this.domElement.clientWidth) * 2 - 1, -(event.clientY / this.domElement.clientHeight) * 2 + 1);
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    
                    const intersects = this.raycaster.intersectObjects(this.handles.children, false);
                    if (intersects.length > 0) {
                        event.stopPropagation();
                        this.controls.enabled = false;
                        this.activeHandle = intersects[0].object;

                        // Store initial state
                        this.objectStartPos.copy(this.attachedObject.position);
                        this.objectStartDims = { ...this.attachedObject.userData.dimensions };
                        
                        // Set up drag plane facing the camera, positioned at the handle's location
                        this.activeHandle.getWorldPosition(this.dragStartWorld);
                        const planeNormal = this.camera.getWorldDirection(new THREE.Vector3()).negate();
                        this.dragPlane.setFromNormalAndCoplanarPoint(planeNormal, this.dragStartWorld);

                        // Determine the handle's movement axis in world space
                        this.handleAxisWorld.copy(this.activeHandle.userData.axis).applyQuaternion(this.attachedObject.quaternion).normalize();

                        // Calculate the anchor point (opposite side of the object) in world space
                        this._calculateAnchorPoint();
                    }
                }

                _calculateAnchorPoint() {
                    const handleAxis = this.activeHandle.userData.axis;
                    const { width, height, depth } = this.objectStartDims;
                    const visualDepth = depth || 0.1;
                    
                    // Vector from object center to the anchor point, in local space
                    const anchorOffsetLocal = new THREE.Vector3(
                       -handleAxis.x * width / 2,
                       handleAxis.y > 0 ? 0 : height, // anchor bottom for top handle, anchor top for bottom handle
                       -handleAxis.z * visualDepth / 2
                    );
                    
                    // Special case for bottom handle, its y anchor is the top
                    if (handleAxis.y < 0) {
                        anchorOffsetLocal.y = height;
                    } else if (handleAxis.y > 0) { // Top handle
                        anchorOffsetLocal.y = 0; // Anchor is at the base
                    } else { // Side handles
                        anchorOffsetLocal.y = height / 2;
                    }

                    // Transform local offset by object's rotation and add to start position
                    this.anchorPoint.copy(this.objectStartPos).add(anchorOffsetLocal.applyQuaternion(this.attachedObject.quaternion));
                }


                _onMouseMove(event) {
                    if (!this.activeHandle) return;
                    event.preventDefault();

                    this.mouse.set((event.clientX / this.domElement.clientWidth) * 2 - 1, -(event.clientY / this.domElement.clientHeight) * 2 + 1);
                    this.raycaster.setFromCamera(this.mouse, this.camera);

                    const intersectionPoint = new THREE.Vector3();
                    if (this.raycaster.ray.intersectPlane(this.dragPlane, intersectionPoint)) {
                        
                        const moveVector = new THREE.Vector3().subVectors(intersectionPoint, this.dragStartWorld);
                        const projectedMoveDistance = moveVector.dot(this.handleAxisWorld);
const newDims = { ...this.objectStartDims };
                        const handleAxis = this.activeHandle.userData.axis;

                        // Apply size change based on the projected movement
                        if (Math.abs(handleAxis.x) > 0) { // Resizing width
                            newDims.width = Math.max(0.2, this.objectStartDims.width + projectedMoveDistance * handleAxis.x);
                        } else if (Math.abs(handleAxis.y) > 0) { // Resizing height
                            newDims.height = Math.max(0.2, this.objectStartDims.height + projectedMoveDistance * handleAxis.y);
                        } else if (Math.abs(handleAxis.z) > 0) { // Resizing depth
                           newDims.depth = Math.max(0.2, (this.objectStartDims.depth || 0.1) + projectedMoveDistance * handleAxis.z);
                        }
                        
                        // Calculate the new position to keep the anchor point fixed
                        // The change in position is half the change in size, along the resize axis.
                        const sizeChange = new THREE.Vector3(
                           (newDims.width || 0) - (this.objectStartDims.width || 0),
                           (newDims.height || 0) - (this.objectStartDims.height || 0),
                           (newDims.depth || 0) - (this.objectStartDims.depth || 0)
                        );
                        
                        const positionOffset = new THREE.Vector3(
                            handleAxis.x * sizeChange.x / 2,
                            handleAxis.y * sizeChange.y / 2,
                            handleAxis.z * sizeChange.z / 2
                        );
                        
                        // Apply offset in world space
                        const worldOffset = positionOffset.applyQuaternion(this.attachedObject.quaternion);
                        const newPosition = this.objectStartPos.clone().add(worldOffset);

                        if (this.onResizeCallback) {
                            this.onResizeCallback(this.attachedObject, newDims, newPosition);
                        }
                    }
                }

                _onMouseUp(event) {
                    if (this.activeHandle) {
                        this.world.undoManager.saveState();
                    }
                    this.activeHandle = null;
                    // Only re-enable controls if view is not locked
                    if (!this.world.controlsPanel.config.viewLocked) {
                        this.controls.enabled = true;
                    }
                }
            }
            // --- END OF REPLACEMENT ---


        // --- MAIN SCRIPT INITIALIZATION ---
        function init() {
            const container = document.querySelector('#scene-container');
            const world = new World(container);
            world.start();
        }

        window.onload = init;

        // Info button/modal logic
        (function() {
          const infoBtn = document.getElementById('info-btn');
          const infoModal = document.getElementById('info-modal');
          const closeBtn = document.getElementById('close-info-modal');
          infoBtn.addEventListener('click', () => {
            infoModal.style.display = 'block';
          });
          closeBtn.addEventListener('click', () => {
            infoModal.style.display = 'none';
          });
          // Optionally update build date dynamically
          // document.getElementById('build-date').textContent = new Date().toISOString().slice(0,10);
        })();

        // --- AXIS INDICATOR TOGGLE BUTTON LOGIC (ROBUST VERSION) ---
        document.addEventListener('DOMContentLoaded', function() {
            const btn = document.getElementById('axis-indicator-toggle-btn');
            function updateBtn() {
                try {
                    if (window.world && window.world.controlsPanel && window.world.controlsPanel.config) {
                        if (window.world.controlsPanel.config.showAxisIndicator) {
                            btn.textContent = '👁️';
                            btn.title = 'Hide Axis Widget';
                        } else {
                            btn.textContent = '🚫';
                            btn.title = 'Show Axis Widget';
                        }
                    }
                } catch (e) { /* Do nothing */ }
            }
            btn.addEventListener('click', function() {
                try {
                    if (window.world && window.world.controlsPanel && window.world.toggleAxisIndicator) {
                        const newState = !window.world.controlsPanel.config.showAxisIndicator;
                        window.world.controlsPanel.config.showAxisIndicator = newState;
                        window.world.toggleAxisIndicator(newState);
                        updateBtn();
                    }
                } catch (e) { /* Do nothing */ }
            });
            // Listen for Tweakpane changes (polling, since no event bus)
            setInterval(updateBtn, 500);
            // Initial state
            updateBtn();
        });

    </script>
</body>
</html>